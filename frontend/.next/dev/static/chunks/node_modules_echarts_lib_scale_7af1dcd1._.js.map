{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/madhusudhan/Documents/autosense-analytics/frontend/node_modules/echarts/lib/scale/break.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n;\nvar _impl = null;\nexport function registerScaleBreakHelperImpl(impl) {\n  if (!_impl) {\n    _impl = impl;\n  }\n}\nexport function getScaleBreakHelper() {\n  return _impl;\n}"],"names":[],"mappings":"AACA;;;;;;;;;;;;;;;;;AAiBA,GAGA;;CAEC,GAED;;;;;;;;;;;;;;;;;AAiBA;;;;;;;AAEA,IAAI,QAAQ;AACL,SAAS,6BAA6B,IAAI;IAC/C,IAAI,CAAC,OAAO;QACV,QAAQ;IACV;AACF;AACO,SAAS;IACd,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file:///Users/madhusudhan/Documents/autosense-analytics/frontend/node_modules/echarts/lib/scale/helper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { getPrecision, round, nice, quantityExponent } from '../util/number.js';\nimport { bind } from 'zrender/lib/core/util.js';\nexport function isValueNice(val) {\n  var exp10 = Math.pow(10, quantityExponent(Math.abs(val)));\n  var f = Math.abs(val / exp10);\n  return f === 0 || f === 1 || f === 2 || f === 3 || f === 5;\n}\nexport function isIntervalOrLogScale(scale) {\n  return scale.type === 'interval' || scale.type === 'log';\n}\n/**\n * @param extent Both extent[0] and extent[1] should be valid number.\n *               Should be extent[0] < extent[1].\n * @param splitNumber splitNumber should be >= 1.\n */\nexport function intervalScaleNiceTicks(extent, spanWithBreaks, splitNumber, minInterval, maxInterval) {\n  var result = {};\n  var interval = result.interval = nice(spanWithBreaks / splitNumber, true);\n  if (minInterval != null && interval < minInterval) {\n    interval = result.interval = minInterval;\n  }\n  if (maxInterval != null && interval > maxInterval) {\n    interval = result.interval = maxInterval;\n  }\n  // Tow more digital for tick.\n  var precision = result.intervalPrecision = getIntervalPrecision(interval);\n  // Niced extent inside original extent\n  var niceTickExtent = result.niceTickExtent = [round(Math.ceil(extent[0] / interval) * interval, precision), round(Math.floor(extent[1] / interval) * interval, precision)];\n  fixExtent(niceTickExtent, extent);\n  return result;\n}\nexport function increaseInterval(interval) {\n  var exp10 = Math.pow(10, quantityExponent(interval));\n  // Increase interval\n  var f = interval / exp10;\n  if (!f) {\n    f = 1;\n  } else if (f === 2) {\n    f = 3;\n  } else if (f === 3) {\n    f = 5;\n  } else {\n    // f is 1 or 5\n    f *= 2;\n  }\n  return round(f * exp10);\n}\n/**\n * @return interval precision\n */\nexport function getIntervalPrecision(interval) {\n  // Tow more digital for tick.\n  return getPrecision(interval) + 2;\n}\nfunction clamp(niceTickExtent, idx, extent) {\n  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n}\n// In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\nexport function fixExtent(niceTickExtent, extent) {\n  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n  clamp(niceTickExtent, 0, extent);\n  clamp(niceTickExtent, 1, extent);\n  if (niceTickExtent[0] > niceTickExtent[1]) {\n    niceTickExtent[0] = niceTickExtent[1];\n  }\n}\nexport function contain(val, extent) {\n  return val >= extent[0] && val <= extent[1];\n}\nvar ScaleCalculator = /** @class */function () {\n  function ScaleCalculator() {\n    this.normalize = normalize;\n    this.scale = scale;\n  }\n  ScaleCalculator.prototype.updateMethods = function (brkCtx) {\n    if (brkCtx.hasBreaks()) {\n      this.normalize = bind(brkCtx.normalize, brkCtx);\n      this.scale = bind(brkCtx.scale, brkCtx);\n    } else {\n      this.normalize = normalize;\n      this.scale = scale;\n    }\n  };\n  return ScaleCalculator;\n}();\nexport { ScaleCalculator };\nfunction normalize(val, extent) {\n  if (extent[1] === extent[0]) {\n    return 0.5;\n  }\n  return (val - extent[0]) / (extent[1] - extent[0]);\n}\nfunction scale(val, extent) {\n  return val * (extent[1] - extent[0]) + extent[0];\n}\nexport function logTransform(base, extent, noClampNegative) {\n  var loggedBase = Math.log(base);\n  return [\n  // log(negative) is NaN, so safe guard here.\n  // PENDING: But even getting a -Infinity still does not make sense in extent.\n  //  Just keep it as is, getting a NaN to make some previous cases works by coincidence.\n  Math.log(noClampNegative ? extent[0] : Math.max(0, extent[0])) / loggedBase, Math.log(noClampNegative ? extent[1] : Math.max(0, extent[1])) / loggedBase];\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 222, "column": 0}, "map": {"version":3,"sources":["file:///Users/madhusudhan/Documents/autosense-analytics/frontend/node_modules/echarts/lib/scale/Scale.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as clazzUtil from '../util/clazz.js';\nimport { ScaleCalculator } from './helper.js';\nimport { bind } from 'zrender/lib/core/util.js';\nimport { getScaleBreakHelper } from './break.js';\nvar Scale = /** @class */function () {\n  function Scale(setting) {\n    this._calculator = new ScaleCalculator();\n    this._setting = setting || {};\n    this._extent = [Infinity, -Infinity];\n    var scaleBreakHelper = getScaleBreakHelper();\n    if (scaleBreakHelper) {\n      this._brkCtx = scaleBreakHelper.createScaleBreakContext();\n      this._brkCtx.update(this._extent);\n    }\n  }\n  Scale.prototype.getSetting = function (name) {\n    return this._setting[name];\n  };\n  /**\n   * [CAVEAT]: It should not be overridden!\n   */\n  Scale.prototype._innerUnionExtent = function (other) {\n    var extent = this._extent;\n    // Considered that number could be NaN and should not write into the extent.\n    this._innerSetExtent(other[0] < extent[0] ? other[0] : extent[0], other[1] > extent[1] ? other[1] : extent[1]);\n  };\n  /**\n   * Set extent from data\n   */\n  Scale.prototype.unionExtentFromData = function (data, dim) {\n    this._innerUnionExtent(data.getApproximateExtent(dim));\n  };\n  /**\n   * Get a new slice of extent.\n   * Extent is always in increase order.\n   */\n  Scale.prototype.getExtent = function () {\n    return this._extent.slice();\n  };\n  Scale.prototype.setExtent = function (start, end) {\n    this._innerSetExtent(start, end);\n  };\n  /**\n   * [CAVEAT]: It should not be overridden!\n   */\n  Scale.prototype._innerSetExtent = function (start, end) {\n    var thisExtent = this._extent;\n    if (!isNaN(start)) {\n      thisExtent[0] = start;\n    }\n    if (!isNaN(end)) {\n      thisExtent[1] = end;\n    }\n    this._brkCtx && this._brkCtx.update(thisExtent);\n  };\n  /**\n   * Prerequisite: Scale#parse is ready.\n   */\n  Scale.prototype.setBreaksFromOption = function (breakOptionList) {\n    var scaleBreakHelper = getScaleBreakHelper();\n    if (scaleBreakHelper) {\n      this._innerSetBreak(scaleBreakHelper.parseAxisBreakOption(breakOptionList, bind(this.parse, this)));\n    }\n  };\n  /**\n   * [CAVEAT]: It should not be overridden!\n   */\n  Scale.prototype._innerSetBreak = function (parsed) {\n    if (this._brkCtx) {\n      this._brkCtx.setBreaks(parsed);\n      this._calculator.updateMethods(this._brkCtx);\n      this._brkCtx.update(this._extent);\n    }\n  };\n  /**\n   * [CAVEAT]: It should not be overridden!\n   */\n  Scale.prototype._innerGetBreaks = function () {\n    return this._brkCtx ? this._brkCtx.breaks : [];\n  };\n  /**\n   * Do not expose the internal `_breaks` unless necessary.\n   */\n  Scale.prototype.hasBreaks = function () {\n    return this._brkCtx ? this._brkCtx.hasBreaks() : false;\n  };\n  Scale.prototype._getExtentSpanWithBreaks = function () {\n    return this._brkCtx && this._brkCtx.hasBreaks() ? this._brkCtx.getExtentSpan() : this._extent[1] - this._extent[0];\n  };\n  /**\n   * If value is in extent range\n   */\n  Scale.prototype.isInExtentRange = function (value) {\n    return this._extent[0] <= value && this._extent[1] >= value;\n  };\n  /**\n   * When axis extent depends on data and no data exists,\n   * axis ticks should not be drawn, which is named 'blank'.\n   */\n  Scale.prototype.isBlank = function () {\n    return this._isBlank;\n  };\n  /**\n   * When axis extent depends on data and no data exists,\n   * axis ticks should not be drawn, which is named 'blank'.\n   */\n  Scale.prototype.setBlank = function (isBlank) {\n    this._isBlank = isBlank;\n  };\n  return Scale;\n}();\nclazzUtil.enableClassManagement(Scale);\nexport default Scale;"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 375, "column": 0}, "map": {"version":3,"sources":["file:///Users/madhusudhan/Documents/autosense-analytics/frontend/node_modules/echarts/lib/scale/Ordinal.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\n/**\n * Linear continuous scale\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n// FIXME only one data\nimport Scale from './Scale.js';\nimport OrdinalMeta from '../data/OrdinalMeta.js';\nimport * as scaleHelper from './helper.js';\nimport { isArray, map, isObject, isString } from 'zrender/lib/core/util.js';\nvar OrdinalScale = /** @class */function (_super) {\n  __extends(OrdinalScale, _super);\n  function OrdinalScale(setting) {\n    var _this = _super.call(this, setting) || this;\n    _this.type = 'ordinal';\n    var ordinalMeta = _this.getSetting('ordinalMeta');\n    // Caution: Should not use instanceof, consider ec-extensions using\n    // import approach to get OrdinalMeta class.\n    if (!ordinalMeta) {\n      ordinalMeta = new OrdinalMeta({});\n    }\n    if (isArray(ordinalMeta)) {\n      ordinalMeta = new OrdinalMeta({\n        categories: map(ordinalMeta, function (item) {\n          return isObject(item) ? item.value : item;\n        })\n      });\n    }\n    _this._ordinalMeta = ordinalMeta;\n    _this._extent = _this.getSetting('extent') || [0, ordinalMeta.categories.length - 1];\n    return _this;\n  }\n  OrdinalScale.prototype.parse = function (val) {\n    // Caution: Math.round(null) will return `0` rather than `NaN`\n    if (val == null) {\n      return NaN;\n    }\n    return isString(val) ? this._ordinalMeta.getOrdinal(val)\n    // val might be float.\n    : Math.round(val);\n  };\n  OrdinalScale.prototype.contain = function (val) {\n    return scaleHelper.contain(val, this._extent) && val >= 0 && val < this._ordinalMeta.categories.length;\n  };\n  /**\n   * Normalize given rank or name to linear [0, 1]\n   * @param val raw ordinal number.\n   * @return normalized value in [0, 1].\n   */\n  OrdinalScale.prototype.normalize = function (val) {\n    val = this._getTickNumber(val);\n    return this._calculator.normalize(val, this._extent);\n  };\n  /**\n   * @param val normalized value in [0, 1].\n   * @return raw ordinal number.\n   */\n  OrdinalScale.prototype.scale = function (val) {\n    val = Math.round(this._calculator.scale(val, this._extent));\n    return this.getRawOrdinalNumber(val);\n  };\n  OrdinalScale.prototype.getTicks = function () {\n    var ticks = [];\n    var extent = this._extent;\n    var rank = extent[0];\n    while (rank <= extent[1]) {\n      ticks.push({\n        value: rank\n      });\n      rank++;\n    }\n    return ticks;\n  };\n  OrdinalScale.prototype.getMinorTicks = function (splitNumber) {\n    // Not support.\n    return;\n  };\n  /**\n   * @see `Ordinal['_ordinalNumbersByTick']`\n   */\n  OrdinalScale.prototype.setSortInfo = function (info) {\n    if (info == null) {\n      this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;\n      return;\n    }\n    var infoOrdinalNumbers = info.ordinalNumbers;\n    var ordinalsByTick = this._ordinalNumbersByTick = [];\n    var ticksByOrdinal = this._ticksByOrdinalNumber = [];\n    // Unnecessary support negative tick in `realtimeSort`.\n    var tickNum = 0;\n    var allCategoryLen = this._ordinalMeta.categories.length;\n    for (var len = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len; ++tickNum) {\n      var ordinalNumber = infoOrdinalNumbers[tickNum];\n      ordinalsByTick[tickNum] = ordinalNumber;\n      ticksByOrdinal[ordinalNumber] = tickNum;\n    }\n    // Handle that `series.data` only covers part of the `axis.category.data`.\n    var unusedOrdinal = 0;\n    for (; tickNum < allCategoryLen; ++tickNum) {\n      while (ticksByOrdinal[unusedOrdinal] != null) {\n        unusedOrdinal++;\n      }\n      ;\n      ordinalsByTick.push(unusedOrdinal);\n      ticksByOrdinal[unusedOrdinal] = tickNum;\n    }\n  };\n  OrdinalScale.prototype._getTickNumber = function (ordinal) {\n    var ticksByOrdinalNumber = this._ticksByOrdinalNumber;\n    // also support ordinal out of range of `ordinalMeta.categories.length`,\n    // where ordinal numbers are used as tick value directly.\n    return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;\n  };\n  /**\n   * @usage\n   * ```js\n   * const ordinalNumber = ordinalScale.getRawOrdinalNumber(tickVal);\n   *\n   * // case0\n   * const rawOrdinalValue = axisModel.getCategories()[ordinalNumber];\n   * // case1\n   * const rawOrdinalValue = this._ordinalMeta.categories[ordinalNumber];\n   * // case2\n   * const coord = axis.dataToCoord(ordinalNumber);\n   * ```\n   *\n   * @param {OrdinalNumber} tickNumber index of display\n   */\n  OrdinalScale.prototype.getRawOrdinalNumber = function (tickNumber) {\n    var ordinalNumbersByTick = this._ordinalNumbersByTick;\n    // tickNumber may be out of range, e.g., when axis max is larger than `ordinalMeta.categories.length`.,\n    // where ordinal numbers are used as tick value directly.\n    return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;\n  };\n  /**\n   * Get item on tick\n   */\n  OrdinalScale.prototype.getLabel = function (tick) {\n    if (!this.isBlank()) {\n      var ordinalNumber = this.getRawOrdinalNumber(tick.value);\n      var cateogry = this._ordinalMeta.categories[ordinalNumber];\n      // Note that if no data, ordinalMeta.categories is an empty array.\n      // Return empty if it's not exist.\n      return cateogry == null ? '' : cateogry + '';\n    }\n  };\n  OrdinalScale.prototype.count = function () {\n    return this._extent[1] - this._extent[0] + 1;\n  };\n  /**\n   * @override\n   * If value is in extent range\n   */\n  OrdinalScale.prototype.isInExtentRange = function (value) {\n    value = this._getTickNumber(value);\n    return this._extent[0] <= value && this._extent[1] >= value;\n  };\n  OrdinalScale.prototype.getOrdinalMeta = function () {\n    return this._ordinalMeta;\n  };\n  OrdinalScale.prototype.calcNiceTicks = function () {};\n  OrdinalScale.prototype.calcNiceExtent = function () {};\n  OrdinalScale.type = 'ordinal';\n  return OrdinalScale;\n}(Scale);\nScale.registerClass(OrdinalScale);\nexport default OrdinalScale;"],"names":[],"mappings":"AACA;;;;;;;;;;;;;;;;;AAiBA,GAGA;;CAEC,GAED;;;;;;;;;;;;;;;;;AAiBA;;;;AACA;AACA;;;CAGC,GACD,sBAAsB;AACtB;AACA;AACA;AACA;;;;;;AACA,IAAI,eAAe,WAAW,GAAE,SAAU,MAAM;IAC9C,IAAA,gLAAS,EAAC,cAAc;IACxB,SAAS,aAAa,OAAO;QAC3B,IAAI,QAAQ,OAAO,IAAI,CAAC,IAAI,EAAE,YAAY,IAAI;QAC9C,MAAM,IAAI,GAAG;QACb,IAAI,cAAc,MAAM,UAAU,CAAC;QACnC,mEAAmE;QACnE,4CAA4C;QAC5C,IAAI,CAAC,aAAa;YAChB,cAAc,IAAI,mKAAW,CAAC,CAAC;QACjC;QACA,IAAI,IAAA,4JAAO,EAAC,cAAc;YACxB,cAAc,IAAI,mKAAW,CAAC;gBAC5B,YAAY,IAAA,wJAAG,EAAC,aAAa,SAAU,IAAI;oBACzC,OAAO,IAAA,6JAAQ,EAAC,QAAQ,KAAK,KAAK,GAAG;gBACvC;YACF;QACF;QACA,MAAM,YAAY,GAAG;QACrB,MAAM,OAAO,GAAG,MAAM,UAAU,CAAC,aAAa;YAAC;YAAG,YAAY,UAAU,CAAC,MAAM,GAAG;SAAE;QACpF,OAAO;IACT;IACA,aAAa,SAAS,CAAC,KAAK,GAAG,SAAU,GAAG;QAC1C,8DAA8D;QAC9D,IAAI,OAAO,MAAM;YACf,OAAO;QACT;QACA,OAAO,IAAA,6JAAQ,EAAC,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,OAElD,KAAK,KAAK,CAAC;IACf;IACA,aAAa,SAAS,CAAC,OAAO,GAAG,SAAU,GAAG;QAC5C,OAAO,+JAAmB,CAAC,KAAK,IAAI,CAAC,OAAO,KAAK,OAAO,KAAK,MAAM,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,MAAM;IACxG;IACA;;;;GAIC,GACD,aAAa,SAAS,CAAC,SAAS,GAAG,SAAU,GAAG;QAC9C,MAAM,IAAI,CAAC,cAAc,CAAC;QAC1B,OAAO,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,IAAI,CAAC,OAAO;IACrD;IACA;;;GAGC,GACD,aAAa,SAAS,CAAC,KAAK,GAAG,SAAU,GAAG;QAC1C,MAAM,KAAK,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,OAAO;QACzD,OAAO,IAAI,CAAC,mBAAmB,CAAC;IAClC;IACA,aAAa,SAAS,CAAC,QAAQ,GAAG;QAChC,IAAI,QAAQ,EAAE;QACd,IAAI,SAAS,IAAI,CAAC,OAAO;QACzB,IAAI,OAAO,MAAM,CAAC,EAAE;QACpB,MAAO,QAAQ,MAAM,CAAC,EAAE,CAAE;YACxB,MAAM,IAAI,CAAC;gBACT,OAAO;YACT;YACA;QACF;QACA,OAAO;IACT;IACA,aAAa,SAAS,CAAC,aAAa,GAAG,SAAU,WAAW;QAC1D,eAAe;QACf;IACF;IACA;;GAEC,GACD,aAAa,SAAS,CAAC,WAAW,GAAG,SAAU,IAAI;QACjD,IAAI,QAAQ,MAAM;YAChB,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,qBAAqB,GAAG;YAC1D;QACF;QACA,IAAI,qBAAqB,KAAK,cAAc;QAC5C,IAAI,iBAAiB,IAAI,CAAC,qBAAqB,GAAG,EAAE;QACpD,IAAI,iBAAiB,IAAI,CAAC,qBAAqB,GAAG,EAAE;QACpD,uDAAuD;QACvD,IAAI,UAAU;QACd,IAAI,iBAAiB,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,MAAM;QACxD,IAAK,IAAI,MAAM,KAAK,GAAG,CAAC,gBAAgB,mBAAmB,MAAM,GAAG,UAAU,KAAK,EAAE,QAAS;YAC5F,IAAI,gBAAgB,kBAAkB,CAAC,QAAQ;YAC/C,cAAc,CAAC,QAAQ,GAAG;YAC1B,cAAc,CAAC,cAAc,GAAG;QAClC;QACA,0EAA0E;QAC1E,IAAI,gBAAgB;QACpB,MAAO,UAAU,gBAAgB,EAAE,QAAS;YAC1C,MAAO,cAAc,CAAC,cAAc,IAAI,KAAM;gBAC5C;YACF;;YAEA,eAAe,IAAI,CAAC;YACpB,cAAc,CAAC,cAAc,GAAG;QAClC;IACF;IACA,aAAa,SAAS,CAAC,cAAc,GAAG,SAAU,OAAO;QACvD,IAAI,uBAAuB,IAAI,CAAC,qBAAqB;QACrD,wEAAwE;QACxE,yDAAyD;QACzD,OAAO,wBAAwB,WAAW,KAAK,UAAU,qBAAqB,MAAM,GAAG,oBAAoB,CAAC,QAAQ,GAAG;IACzH;IACA;;;;;;;;;;;;;;GAcC,GACD,aAAa,SAAS,CAAC,mBAAmB,GAAG,SAAU,UAAU;QAC/D,IAAI,uBAAuB,IAAI,CAAC,qBAAqB;QACrD,uGAAuG;QACvG,yDAAyD;QACzD,OAAO,wBAAwB,cAAc,KAAK,aAAa,qBAAqB,MAAM,GAAG,oBAAoB,CAAC,WAAW,GAAG;IAClI;IACA;;GAEC,GACD,aAAa,SAAS,CAAC,QAAQ,GAAG,SAAU,IAAI;QAC9C,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI;YACnB,IAAI,gBAAgB,IAAI,CAAC,mBAAmB,CAAC,KAAK,KAAK;YACvD,IAAI,WAAW,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,cAAc;YAC1D,kEAAkE;YAClE,kCAAkC;YAClC,OAAO,YAAY,OAAO,KAAK,WAAW;QAC5C;IACF;IACA,aAAa,SAAS,CAAC,KAAK,GAAG;QAC7B,OAAO,IAAI,CAAC,OAAO,CAAC,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,EAAE,GAAG;IAC7C;IACA;;;GAGC,GACD,aAAa,SAAS,CAAC,eAAe,GAAG,SAAU,KAAK;QACtD,QAAQ,IAAI,CAAC,cAAc,CAAC;QAC5B,OAAO,IAAI,CAAC,OAAO,CAAC,EAAE,IAAI,SAAS,IAAI,CAAC,OAAO,CAAC,EAAE,IAAI;IACxD;IACA,aAAa,SAAS,CAAC,cAAc,GAAG;QACtC,OAAO,IAAI,CAAC,YAAY;IAC1B;IACA,aAAa,SAAS,CAAC,aAAa,GAAG,YAAa;IACpD,aAAa,SAAS,CAAC,cAAc,GAAG,YAAa;IACrD,aAAa,IAAI,GAAG;IACpB,OAAO;AACT,EAAE,8JAAK;AACP,8JAAK,CAAC,aAAa,CAAC;uCACL","ignoreList":[0]}},
    {"offset": {"line": 585, "column": 0}, "map": {"version":3,"sources":["file:///Users/madhusudhan/Documents/autosense-analytics/frontend/node_modules/echarts/lib/scale/Interval.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as numberUtil from '../util/number.js';\nimport * as formatUtil from '../util/format.js';\nimport Scale from './Scale.js';\nimport * as helper from './helper.js';\nimport { getScaleBreakHelper } from './break.js';\nvar roundNumber = numberUtil.round;\nvar IntervalScale = /** @class */function (_super) {\n  __extends(IntervalScale, _super);\n  function IntervalScale() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = 'interval';\n    // Step is calculated in adjustExtent.\n    _this._interval = 0;\n    _this._intervalPrecision = 2;\n    return _this;\n  }\n  IntervalScale.prototype.parse = function (val) {\n    // `Scale#parse` (and its overrids) are typically applied at the axis values input\n    // in echarts option. e.g., `axis.min/max`, `dataZoom.min/max`, etc.\n    // but `series.data` is not included, which uses `dataValueHelper.ts`#`parseDataValue`.\n    // `Scale#parse` originally introduced in fb8c813215098b9d2458966229bb95c510883d5e\n    // at 2016 for dataZoom start/end settings (See `parseAxisModelMinMax`).\n    //\n    // Historically `scale/Interval.ts` returns the input value directly. But numeric\n    // values (such as a number-like string '123') effectively passed through here and\n    // were involved in calculations, which was error-prone and inconsistent with the\n    // declared TS return type. Previously such issues are fixed separately in different\n    // places case by case (such as #2475).\n    //\n    // Now, we perform actual parse to ensure its `number` type here. The parsing rule\n    // follows the series data parsing rule (`dataValueHelper.ts`#`parseDataValue`)\n    // and maintains compatibility as much as possible (thus a more strict parsing\n    // `number.ts`#`numericToNumber` is not used here.)\n    //\n    // FIXME: `ScaleDataValue` also need to be modified to include numeric string type,\n    //  since it effectively does.\n    return val == null || val === '' ? NaN\n    // If string (like '-'), using '+' parse to NaN\n    // If object, also parse to NaN\n    : Number(val);\n  };\n  IntervalScale.prototype.contain = function (val) {\n    return helper.contain(val, this._extent);\n  };\n  IntervalScale.prototype.normalize = function (val) {\n    return this._calculator.normalize(val, this._extent);\n  };\n  IntervalScale.prototype.scale = function (val) {\n    return this._calculator.scale(val, this._extent);\n  };\n  IntervalScale.prototype.getInterval = function () {\n    return this._interval;\n  };\n  IntervalScale.prototype.setInterval = function (interval) {\n    this._interval = interval;\n    // Dropped auto calculated niceExtent and use user-set extent.\n    // We assume user wants to set both interval, min, max to get a better result.\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  };\n  /**\n   * @override\n   */\n  IntervalScale.prototype.getTicks = function (opt) {\n    opt = opt || {};\n    var interval = this._interval;\n    var extent = this._extent;\n    var niceTickExtent = this._niceExtent;\n    var intervalPrecision = this._intervalPrecision;\n    var scaleBreakHelper = getScaleBreakHelper();\n    var ticks = [];\n    // If interval is 0, return [];\n    if (!interval) {\n      return ticks;\n    }\n    if (opt.breakTicks === 'only_break' && scaleBreakHelper) {\n      scaleBreakHelper.addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent);\n      return ticks;\n    }\n    // Consider this case: using dataZoom toolbox, zoom and zoom.\n    var safeLimit = 10000;\n    if (extent[0] < niceTickExtent[0]) {\n      if (opt.expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[0]\n        });\n      }\n    }\n    var estimateNiceMultiple = function (tickVal, targetTick) {\n      return Math.round((targetTick - tickVal) / interval);\n    };\n    var tick = niceTickExtent[0];\n    while (tick <= niceTickExtent[1]) {\n      ticks.push({\n        value: tick\n      });\n      // Avoid rounding error\n      tick = roundNumber(tick + interval, intervalPrecision);\n      if (this._brkCtx) {\n        var moreMultiple = this._brkCtx.calcNiceTickMultiple(tick, estimateNiceMultiple);\n        if (moreMultiple >= 0) {\n          tick = roundNumber(tick + moreMultiple * interval, intervalPrecision);\n        }\n      }\n      if (ticks.length > 0 && tick === ticks[ticks.length - 1].value) {\n        // Consider out of safe float point, e.g.,\n        // -3711126.9907707 + 2e-10 === -3711126.9907707\n        break;\n      }\n      if (ticks.length > safeLimit) {\n        return [];\n      }\n    }\n    // Consider this case: the last item of ticks is smaller\n    // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];\n    if (extent[1] > lastNiceTick) {\n      if (opt.expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(lastNiceTick + interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[1]\n        });\n      }\n    }\n    if (scaleBreakHelper) {\n      scaleBreakHelper.pruneTicksByBreak(opt.pruneByBreak, ticks, this._brkCtx.breaks, function (item) {\n        return item.value;\n      }, this._interval, this._extent);\n    }\n    if (opt.breakTicks !== 'none' && scaleBreakHelper) {\n      scaleBreakHelper.addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent);\n    }\n    return ticks;\n  };\n  IntervalScale.prototype.getMinorTicks = function (splitNumber) {\n    var ticks = this.getTicks({\n      expandToNicedExtent: true\n    });\n    // NOTE: In log-scale, do not support minor ticks when breaks exist.\n    //  because currently log-scale minor ticks is calculated based on raw values\n    //  rather than log-transformed value, due to an odd effect when breaks exist.\n    var minorTicks = [];\n    var extent = this.getExtent();\n    for (var i = 1; i < ticks.length; i++) {\n      var nextTick = ticks[i];\n      var prevTick = ticks[i - 1];\n      if (prevTick[\"break\"] || nextTick[\"break\"]) {\n        // Do not build minor ticks to the adjacent ticks to breaks ticks,\n        // since the interval might be irregular.\n        continue;\n      }\n      var count = 0;\n      var minorTicksGroup = [];\n      var interval = nextTick.value - prevTick.value;\n      var minorInterval = interval / splitNumber;\n      var minorIntervalPrecision = helper.getIntervalPrecision(minorInterval);\n      while (count < splitNumber - 1) {\n        var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval, minorIntervalPrecision);\n        // For the first and last interval. The count may be less than splitNumber.\n        if (minorTick > extent[0] && minorTick < extent[1]) {\n          minorTicksGroup.push(minorTick);\n        }\n        count++;\n      }\n      var scaleBreakHelper = getScaleBreakHelper();\n      scaleBreakHelper && scaleBreakHelper.pruneTicksByBreak('auto', minorTicksGroup, this._getNonTransBreaks(), function (value) {\n        return value;\n      }, this._interval, extent);\n      minorTicks.push(minorTicksGroup);\n    }\n    return minorTicks;\n  };\n  IntervalScale.prototype._getNonTransBreaks = function () {\n    return this._brkCtx ? this._brkCtx.breaks : [];\n  };\n  /**\n   * @param opt.precision If 'auto', use nice presision.\n   * @param opt.pad returns 1.50 but not 1.5 if precision is 2.\n   */\n  IntervalScale.prototype.getLabel = function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n    var precision = opt && opt.precision;\n    if (precision == null) {\n      precision = numberUtil.getPrecision(data.value) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    }\n    // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n    var dataNum = roundNumber(data.value, precision, true);\n    return formatUtil.addCommas(dataNum);\n  };\n  /**\n   * FIXME: refactor - disallow override, use composition instead.\n   *\n   * The override of `calcNiceTicks` should ensure these members are provided:\n   *  this._intervalPrecision\n   *  this._interval\n   *\n   * @param splitNumber By default `5`.\n   */\n  IntervalScale.prototype.calcNiceTicks = function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent.slice();\n    var span = this._getExtentSpanWithBreaks();\n    if (!isFinite(span)) {\n      return;\n    }\n    // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n      this._innerSetExtent(extent[0], extent[1]);\n      extent = this._extent.slice();\n    }\n    var result = helper.intervalScaleNiceTicks(extent, span, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  };\n  IntervalScale.prototype.calcNiceExtent = function (opt) {\n    var extent = this._extent.slice();\n    // If extent start and end are same, expand them\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        // Note that extents can be both negative. See #13154\n        var expandSize = Math.abs(extent[0]);\n        // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n    var span = extent[1] - extent[0];\n    // If there are no data and extent are [Infinity, -Infinity]\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n    this._innerSetExtent(extent[0], extent[1]);\n    extent = this._extent.slice();\n    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n    var interval = this._interval;\n    var intervalPrecition = this._intervalPrecision;\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval, intervalPrecition);\n    }\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval, intervalPrecition);\n    }\n    this._innerSetExtent(extent[0], extent[1]);\n  };\n  IntervalScale.prototype.setNiceExtent = function (min, max) {\n    this._niceExtent = [min, max];\n  };\n  IntervalScale.type = 'interval';\n  return IntervalScale;\n}(Scale);\nScale.registerClass(IntervalScale);\nexport default IntervalScale;"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 910, "column": 0}, "map": {"version":3,"sources":["file:///Users/madhusudhan/Documents/autosense-analytics/frontend/node_modules/echarts/lib/scale/Time.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\n/*\n* A third-party license is embedded for some of the code in this file:\n* The \"scaleLevels\" was originally copied from \"d3.js\" with some\n* modifications made for this project.\n* (See more details in the comment on the definition of \"scaleLevels\" below.)\n* The use of the source code of this file is also subject to the terms\n* and consitions of the license of \"d3.js\" (BSD-3Clause, see\n* </licenses/LICENSE-d3>).\n*/\n// [About UTC and local time zone]:\n// In most cases, `number.parseDate` will treat input data string as local time\n// (except time zone is specified in time string). And `format.formateTime` returns\n// local time by default. option.useUTC is false by default. This design has\n// considered these common cases:\n// (1) Time that is persistent in server is in UTC, but it is needed to be displayed\n// in local time by default.\n// (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n// as its original time, without any time difference.\nimport * as numberUtil from '../util/number.js';\nimport { ONE_SECOND, ONE_MINUTE, ONE_HOUR, ONE_DAY, ONE_YEAR, format, leveledFormat, timeUnits, fullLeveledFormatter, getPrimaryTimeUnit, isPrimaryTimeUnit, getDefaultFormatPrecisionOfInterval, fullYearGetterName, monthSetterName, fullYearSetterName, dateSetterName, hoursGetterName, hoursSetterName, minutesSetterName, secondsSetterName, millisecondsSetterName, monthGetterName, dateGetterName, minutesGetterName, secondsGetterName, millisecondsGetterName, getUnitFromValue, primaryTimeUnits, roundTime } from '../util/time.js';\nimport * as scaleHelper from './helper.js';\nimport IntervalScale from './Interval.js';\nimport Scale from './Scale.js';\nimport { warn } from '../util/log.js';\nimport { each, filter, indexOf, isNumber, map } from 'zrender/lib/core/util.js';\nimport { getScaleBreakHelper } from './break.js';\n// FIXME \nvar bisect = function (a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid][1] < x) {\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n  return lo;\n};\nvar TimeScale = /** @class */function (_super) {\n  __extends(TimeScale, _super);\n  function TimeScale(settings) {\n    var _this = _super.call(this, settings) || this;\n    _this.type = 'time';\n    return _this;\n  }\n  /**\n   * Get label is mainly for other components like dataZoom, tooltip.\n   */\n  TimeScale.prototype.getLabel = function (tick) {\n    var useUTC = this.getSetting('useUTC');\n    return format(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting('locale'));\n  };\n  TimeScale.prototype.getFormattedLabel = function (tick, idx, labelFormatter) {\n    var isUTC = this.getSetting('useUTC');\n    var lang = this.getSetting('locale');\n    return leveledFormat(tick, idx, labelFormatter, lang, isUTC);\n  };\n  /**\n   * @override\n   */\n  TimeScale.prototype.getTicks = function (opt) {\n    opt = opt || {};\n    var interval = this._interval;\n    var extent = this._extent;\n    var scaleBreakHelper = getScaleBreakHelper();\n    var ticks = [];\n    // If interval is 0, return [];\n    if (!interval) {\n      return ticks;\n    }\n    var useUTC = this.getSetting('useUTC');\n    if (scaleBreakHelper && opt.breakTicks === 'only_break') {\n      getScaleBreakHelper().addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent);\n      return ticks;\n    }\n    var extent0Unit = getUnitFromValue(extent[1], useUTC);\n    ticks.push({\n      value: extent[0],\n      time: {\n        level: 0,\n        upperTimeUnit: extent0Unit,\n        lowerTimeUnit: extent0Unit\n      }\n    });\n    var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent, this._getExtentSpanWithBreaks(), this._brkCtx);\n    ticks = ticks.concat(innerTicks);\n    var extent1Unit = getUnitFromValue(extent[1], useUTC);\n    ticks.push({\n      value: extent[1],\n      time: {\n        level: 0,\n        upperTimeUnit: extent1Unit,\n        lowerTimeUnit: extent1Unit\n      }\n    });\n    var isUTC = this.getSetting('useUTC');\n    var upperUnitIndex = primaryTimeUnits.length - 1;\n    var maxLevel = 0;\n    each(ticks, function (tick) {\n      upperUnitIndex = Math.min(upperUnitIndex, indexOf(primaryTimeUnits, tick.time.upperTimeUnit));\n      maxLevel = Math.max(maxLevel, tick.time.level);\n    });\n    if (scaleBreakHelper) {\n      getScaleBreakHelper().pruneTicksByBreak(opt.pruneByBreak, ticks, this._brkCtx.breaks, function (item) {\n        return item.value;\n      }, this._approxInterval, this._extent);\n    }\n    if (scaleBreakHelper && opt.breakTicks !== 'none') {\n      getScaleBreakHelper().addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent, function (trimmedBrk) {\n        // @see `parseTimeAxisLabelFormatterDictionary`.\n        var lowerBrkUnitIndex = Math.max(indexOf(primaryTimeUnits, getUnitFromValue(trimmedBrk.vmin, isUTC)), indexOf(primaryTimeUnits, getUnitFromValue(trimmedBrk.vmax, isUTC)));\n        var upperBrkUnitIndex = 0;\n        for (var unitIdx = 0; unitIdx < primaryTimeUnits.length; unitIdx++) {\n          if (!isPrimaryUnitValueAndGreaterSame(primaryTimeUnits[unitIdx], trimmedBrk.vmin, trimmedBrk.vmax, isUTC)) {\n            upperBrkUnitIndex = unitIdx;\n            break;\n          }\n        }\n        var upperIdx = Math.min(upperBrkUnitIndex, upperUnitIndex);\n        var lowerIdx = Math.max(upperIdx, lowerBrkUnitIndex);\n        return {\n          level: maxLevel,\n          lowerTimeUnit: primaryTimeUnits[lowerIdx],\n          upperTimeUnit: primaryTimeUnits[upperIdx]\n        };\n      });\n    }\n    return ticks;\n  };\n  TimeScale.prototype.calcNiceExtent = function (opt) {\n    var extent = this.getExtent();\n    // If extent start and end are same, expand them\n    if (extent[0] === extent[1]) {\n      // Expand extent\n      extent[0] -= ONE_DAY;\n      extent[1] += ONE_DAY;\n    }\n    // If there are no data and extent are [Infinity, -Infinity]\n    if (extent[1] === -Infinity && extent[0] === Infinity) {\n      var d = new Date();\n      extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      extent[0] = extent[1] - ONE_DAY;\n    }\n    this._innerSetExtent(extent[0], extent[1]);\n    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n  };\n  TimeScale.prototype.calcNiceTicks = function (approxTickNum, minInterval, maxInterval) {\n    approxTickNum = approxTickNum || 10;\n    var span = this._getExtentSpanWithBreaks();\n    this._approxInterval = span / approxTickNum;\n    if (minInterval != null && this._approxInterval < minInterval) {\n      this._approxInterval = minInterval;\n    }\n    if (maxInterval != null && this._approxInterval > maxInterval) {\n      this._approxInterval = maxInterval;\n    }\n    var scaleIntervalsLen = scaleIntervals.length;\n    var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);\n    // Interval that can be used to calculate ticks\n    this._interval = scaleIntervals[idx][1];\n    this._intervalPrecision = scaleHelper.getIntervalPrecision(this._interval);\n    // Min level used when picking ticks from top down.\n    // We check one more level to avoid the ticks are to sparse in some case.\n    this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];\n  };\n  TimeScale.prototype.parse = function (val) {\n    // val might be float.\n    return isNumber(val) ? val : +numberUtil.parseDate(val);\n  };\n  TimeScale.prototype.contain = function (val) {\n    return scaleHelper.contain(val, this._extent);\n  };\n  TimeScale.prototype.normalize = function (val) {\n    return this._calculator.normalize(val, this._extent);\n  };\n  TimeScale.prototype.scale = function (val) {\n    return this._calculator.scale(val, this._extent);\n  };\n  TimeScale.type = 'time';\n  return TimeScale;\n}(IntervalScale);\n/**\n * This implementation was originally copied from \"d3.js\"\n * <https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/time/scale.js>\n * with some modifications made for this program.\n * See the license statement at the head of this file.\n */\nvar scaleIntervals = [\n// Format                           interval\n['second', ONE_SECOND], ['minute', ONE_MINUTE], ['hour', ONE_HOUR], ['quarter-day', ONE_HOUR * 6], ['half-day', ONE_HOUR * 12], ['day', ONE_DAY * 1.2], ['half-week', ONE_DAY * 3.5], ['week', ONE_DAY * 7], ['month', ONE_DAY * 31], ['quarter', ONE_DAY * 95], ['half-year', ONE_YEAR / 2], ['year', ONE_YEAR] // 1Y\n];\nfunction isPrimaryUnitValueAndGreaterSame(unit, valueA, valueB, isUTC) {\n  return roundTime(new Date(valueA), unit, isUTC).getTime() === roundTime(new Date(valueB), unit, isUTC).getTime();\n}\n// function isUnitValueSame(\n//     unit: PrimaryTimeUnit,\n//     valueA: number,\n//     valueB: number,\n//     isUTC: boolean\n// ): boolean {\n//     const dateA = numberUtil.parseDate(valueA) as any;\n//     const dateB = numberUtil.parseDate(valueB) as any;\n//     const isSame = (unit: PrimaryTimeUnit) => {\n//         return getUnitValue(dateA, unit, isUTC)\n//             === getUnitValue(dateB, unit, isUTC);\n//     };\n//     const isSameYear = () => isSame('year');\n//     // const isSameHalfYear = () => isSameYear() && isSame('half-year');\n//     // const isSameQuater = () => isSameYear() && isSame('quarter');\n//     const isSameMonth = () => isSameYear() && isSame('month');\n//     const isSameDay = () => isSameMonth() && isSame('day');\n//     // const isSameHalfDay = () => isSameDay() && isSame('half-day');\n//     const isSameHour = () => isSameDay() && isSame('hour');\n//     const isSameMinute = () => isSameHour() && isSame('minute');\n//     const isSameSecond = () => isSameMinute() && isSame('second');\n//     const isSameMilliSecond = () => isSameSecond() && isSame('millisecond');\n//     switch (unit) {\n//         case 'year':\n//             return isSameYear();\n//         case 'month':\n//             return isSameMonth();\n//         case 'day':\n//             return isSameDay();\n//         case 'hour':\n//             return isSameHour();\n//         case 'minute':\n//             return isSameMinute();\n//         case 'second':\n//             return isSameSecond();\n//         case 'millisecond':\n//             return isSameMilliSecond();\n//     }\n// }\n// const primaryUnitGetters = {\n//     year: fullYearGetterName(),\n//     month: monthGetterName(),\n//     day: dateGetterName(),\n//     hour: hoursGetterName(),\n//     minute: minutesGetterName(),\n//     second: secondsGetterName(),\n//     millisecond: millisecondsGetterName()\n// };\n// const primaryUnitUTCGetters = {\n//     year: fullYearGetterName(true),\n//     month: monthGetterName(true),\n//     day: dateGetterName(true),\n//     hour: hoursGetterName(true),\n//     minute: minutesGetterName(true),\n//     second: secondsGetterName(true),\n//     millisecond: millisecondsGetterName(true)\n// };\n// function moveTick(date: Date, unitName: TimeUnit, step: number, isUTC: boolean) {\n//     step = step || 1;\n//     switch (getPrimaryTimeUnit(unitName)) {\n//         case 'year':\n//             date[fullYearSetterName(isUTC)](date[fullYearGetterName(isUTC)]() + step);\n//             break;\n//         case 'month':\n//             date[monthSetterName(isUTC)](date[monthGetterName(isUTC)]() + step);\n//             break;\n//         case 'day':\n//             date[dateSetterName(isUTC)](date[dateGetterName(isUTC)]() + step);\n//             break;\n//         case 'hour':\n//             date[hoursSetterName(isUTC)](date[hoursGetterName(isUTC)]() + step);\n//             break;\n//         case 'minute':\n//             date[minutesSetterName(isUTC)](date[minutesGetterName(isUTC)]() + step);\n//             break;\n//         case 'second':\n//             date[secondsSetterName(isUTC)](date[secondsGetterName(isUTC)]() + step);\n//             break;\n//         case 'millisecond':\n//             date[millisecondsSetterName(isUTC)](date[millisecondsGetterName(isUTC)]() + step);\n//             break;\n//     }\n//     return date.getTime();\n// }\n// const DATE_INTERVALS = [[8, 7.5], [4, 3.5], [2, 1.5]];\n// const MONTH_INTERVALS = [[6, 5.5], [3, 2.5], [2, 1.5]];\n// const MINUTES_SECONDS_INTERVALS = [[30, 30], [20, 20], [15, 15], [10, 10], [5, 5], [2, 2]];\nfunction getDateInterval(approxInterval, daysInMonth) {\n  approxInterval /= ONE_DAY;\n  return approxInterval > 16 ? 16\n  // Math.floor(daysInMonth / 2) + 1  // In this case we only want one tick between two months.\n  : approxInterval > 7.5 ? 7 // TODO week 7 or day 8?\n  : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;\n}\nfunction getMonthInterval(approxInterval) {\n  var APPROX_ONE_MONTH = 30 * ONE_DAY;\n  approxInterval /= APPROX_ONE_MONTH;\n  return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;\n}\nfunction getHourInterval(approxInterval) {\n  approxInterval /= ONE_HOUR;\n  return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;\n}\nfunction getMinutesAndSecondsInterval(approxInterval, isMinutes) {\n  approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;\n  return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;\n}\nfunction getMillisecondsInterval(approxInterval) {\n  return numberUtil.nice(approxInterval, true);\n}\n// e.g., if the input unit is 'day', start calculate ticks from the first day of\n// that month to make ticks \"nice\".\nfunction getFirstTimestampOfUnit(timestamp, unitName, isUTC) {\n  var upperUnitIdx = Math.max(0, indexOf(primaryTimeUnits, unitName) - 1);\n  return roundTime(new Date(timestamp), primaryTimeUnits[upperUnitIdx], isUTC).getTime();\n}\nfunction createEstimateNiceMultiple(setMethodName, dateMethodInterval) {\n  var tmpDate = new Date(0);\n  tmpDate[setMethodName](1);\n  var tmpTime = tmpDate.getTime();\n  tmpDate[setMethodName](1 + dateMethodInterval);\n  var approxTimeInterval = tmpDate.getTime() - tmpTime;\n  return function (tickVal, targetValue) {\n    // Only in month that accurate result can not get by division of\n    // timestamp interval, but no need accurate here.\n    return Math.max(0, Math.round((targetValue - tickVal) / approxTimeInterval));\n  };\n}\nfunction getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent, extentSpanWithBreaks, brkCtx) {\n  var safeLimit = 10000;\n  var unitNames = timeUnits;\n  var iter = 0;\n  function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out) {\n    var estimateNiceMultiple = createEstimateNiceMultiple(setMethodName, interval);\n    var dateTime = minTimestamp;\n    var date = new Date(dateTime);\n    // if (isDate) {\n    //     d -= 1; // Starts with 0;   PENDING\n    // }\n    while (dateTime < maxTimestamp && dateTime <= extent[1]) {\n      out.push({\n        value: dateTime\n      });\n      if (iter++ > safeLimit) {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('Exceed safe limit in time scale.');\n        }\n        break;\n      }\n      date[setMethodName](date[getMethodName]() + interval);\n      dateTime = date.getTime();\n      if (brkCtx) {\n        var moreMultiple = brkCtx.calcNiceTickMultiple(dateTime, estimateNiceMultiple);\n        if (moreMultiple > 0) {\n          date[setMethodName](date[getMethodName]() + moreMultiple * interval);\n          dateTime = date.getTime();\n        }\n      }\n    }\n    // This extra tick is for calcuating ticks of next level. Will not been added to the final result\n    out.push({\n      value: dateTime,\n      notAdd: true\n    });\n  }\n  function addLevelTicks(unitName, lastLevelTicks, levelTicks) {\n    var newAddedTicks = [];\n    var isFirstLevel = !lastLevelTicks.length;\n    if (isPrimaryUnitValueAndGreaterSame(getPrimaryTimeUnit(unitName), extent[0], extent[1], isUTC)) {\n      return;\n    }\n    if (isFirstLevel) {\n      lastLevelTicks = [{\n        value: getFirstTimestampOfUnit(extent[0], unitName, isUTC)\n      }, {\n        value: extent[1]\n      }];\n    }\n    for (var i = 0; i < lastLevelTicks.length - 1; i++) {\n      var startTick = lastLevelTicks[i].value;\n      var endTick = lastLevelTicks[i + 1].value;\n      if (startTick === endTick) {\n        continue;\n      }\n      var interval = void 0;\n      var getterName = void 0;\n      var setterName = void 0;\n      var isDate = false;\n      switch (unitName) {\n        case 'year':\n          interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));\n          getterName = fullYearGetterName(isUTC);\n          setterName = fullYearSetterName(isUTC);\n          break;\n        case 'half-year':\n        case 'quarter':\n        case 'month':\n          interval = getMonthInterval(approxInterval);\n          getterName = monthGetterName(isUTC);\n          setterName = monthSetterName(isUTC);\n          break;\n        case 'week': // PENDING If week is added. Ignore day.\n        case 'half-week':\n        case 'day':\n          interval = getDateInterval(approxInterval, 31); // Use 32 days and let interval been 16\n          getterName = dateGetterName(isUTC);\n          setterName = dateSetterName(isUTC);\n          isDate = true;\n          break;\n        case 'half-day':\n        case 'quarter-day':\n        case 'hour':\n          interval = getHourInterval(approxInterval);\n          getterName = hoursGetterName(isUTC);\n          setterName = hoursSetterName(isUTC);\n          break;\n        case 'minute':\n          interval = getMinutesAndSecondsInterval(approxInterval, true);\n          getterName = minutesGetterName(isUTC);\n          setterName = minutesSetterName(isUTC);\n          break;\n        case 'second':\n          interval = getMinutesAndSecondsInterval(approxInterval, false);\n          getterName = secondsGetterName(isUTC);\n          setterName = secondsSetterName(isUTC);\n          break;\n        case 'millisecond':\n          interval = getMillisecondsInterval(approxInterval);\n          getterName = millisecondsGetterName(isUTC);\n          setterName = millisecondsSetterName(isUTC);\n          break;\n      }\n      // Notice: This expansion by `getFirstTimestampOfUnit` may cause too many ticks and\n      // iteration. e.g., when three levels of ticks is displayed, which can be caused by\n      // data zoom and axis breaks. Thus trim them here.\n      if (endTick >= extent[0] && startTick <= extent[1]) {\n        addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);\n      }\n      if (unitName === 'year' && levelTicks.length > 1 && i === 0) {\n        // Add nearest years to the left extent.\n        levelTicks.unshift({\n          value: levelTicks[0].value - interval\n        });\n      }\n    }\n    for (var i = 0; i < newAddedTicks.length; i++) {\n      levelTicks.push(newAddedTicks[i]);\n    }\n  }\n  var levelsTicks = [];\n  var currentLevelTicks = [];\n  var tickCount = 0;\n  var lastLevelTickCount = 0;\n  for (var i = 0; i < unitNames.length; ++i) {\n    var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i]);\n    if (!isPrimaryTimeUnit(unitNames[i])) {\n      // TODO\n      continue;\n    }\n    addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);\n    var nextPrimaryTimeUnit = unitNames[i + 1] ? getPrimaryTimeUnit(unitNames[i + 1]) : null;\n    if (primaryTimeUnit !== nextPrimaryTimeUnit) {\n      if (currentLevelTicks.length) {\n        lastLevelTickCount = tickCount;\n        // Remove the duplicate so the tick count can be precisely.\n        currentLevelTicks.sort(function (a, b) {\n          return a.value - b.value;\n        });\n        var levelTicksRemoveDuplicated = [];\n        for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {\n          var tickValue = currentLevelTicks[i_1].value;\n          if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {\n            levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);\n            if (tickValue >= extent[0] && tickValue <= extent[1]) {\n              tickCount++;\n            }\n          }\n        }\n        var targetTickNum = extentSpanWithBreaks / approxInterval;\n        // Added too much in this level and not too less in last level\n        if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {\n          break;\n        }\n        // Only treat primary time unit as one level.\n        levelsTicks.push(levelTicksRemoveDuplicated);\n        if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {\n          break;\n        }\n      }\n      // Reset if next unitName is primary\n      currentLevelTicks = [];\n    }\n  }\n  var levelsTicksInExtent = filter(map(levelsTicks, function (levelTicks) {\n    return filter(levelTicks, function (tick) {\n      return tick.value >= extent[0] && tick.value <= extent[1] && !tick.notAdd;\n    });\n  }), function (levelTicks) {\n    return levelTicks.length > 0;\n  });\n  var ticks = [];\n  var maxLevel = levelsTicksInExtent.length - 1;\n  for (var i = 0; i < levelsTicksInExtent.length; ++i) {\n    var levelTicks = levelsTicksInExtent[i];\n    for (var k = 0; k < levelTicks.length; ++k) {\n      var unit = getUnitFromValue(levelTicks[k].value, isUTC);\n      ticks.push({\n        value: levelTicks[k].value,\n        time: {\n          level: maxLevel - i,\n          upperTimeUnit: unit,\n          lowerTimeUnit: unit\n        }\n      });\n    }\n  }\n  ticks.sort(function (a, b) {\n    return a.value - b.value;\n  });\n  // Remove duplicates\n  var result = [];\n  for (var i = 0; i < ticks.length; ++i) {\n    if (i === 0 || ticks[i].value !== ticks[i - 1].value) {\n      result.push(ticks[i]);\n    }\n  }\n  return result;\n}\nScale.registerClass(TimeScale);\nexport default TimeScale;"],"names":[],"mappings":"AACA;;;;;;;;;;;;;;;;;AAiBA,GAGA;;CAEC,GAED;;;;;;;;;;;;;;;;;AAiBA;;;;AAoVY;AAnVZ;AACA;;;;;;;;AAQA,GACA,mCAAmC;AACnC,+EAA+E;AAC/E,mFAAmF;AACnF,4EAA4E;AAC5E,iCAAiC;AACjC,oFAAoF;AACpF,4BAA4B;AAC5B,iFAAiF;AACjF,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AACA,YAAY;AACZ,IAAI,SAAS,SAAU,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE;IACjC,MAAO,KAAK,GAAI;QACd,IAAI,MAAM,KAAK,OAAO;QACtB,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE,GAAG,GAAG;YACjB,KAAK,MAAM;QACb,OAAO;YACL,KAAK;QACP;IACF;IACA,OAAO;AACT;AACA,IAAI,YAAY,WAAW,GAAE,SAAU,MAAM;IAC3C,IAAA,gLAAS,EAAC,WAAW;IACrB,SAAS,UAAU,QAAQ;QACzB,IAAI,QAAQ,OAAO,IAAI,CAAC,IAAI,EAAE,aAAa,IAAI;QAC/C,MAAM,IAAI,GAAG;QACb,OAAO;IACT;IACA;;GAEC,GACD,UAAU,SAAS,CAAC,QAAQ,GAAG,SAAU,IAAI;QAC3C,IAAI,SAAS,IAAI,CAAC,UAAU,CAAC;QAC7B,OAAO,IAAA,2JAAM,EAAC,KAAK,KAAK,EAAE,yKAAoB,CAAC,IAAA,wLAAmC,EAAC,IAAA,uKAAkB,EAAC,IAAI,CAAC,aAAa,GAAG,IAAI,yKAAoB,CAAC,MAAM,EAAE,QAAQ,IAAI,CAAC,UAAU,CAAC;IACtL;IACA,UAAU,SAAS,CAAC,iBAAiB,GAAG,SAAU,IAAI,EAAE,GAAG,EAAE,cAAc;QACzE,IAAI,QAAQ,IAAI,CAAC,UAAU,CAAC;QAC5B,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC;QAC3B,OAAO,IAAA,kKAAa,EAAC,MAAM,KAAK,gBAAgB,MAAM;IACxD;IACA;;GAEC,GACD,UAAU,SAAS,CAAC,QAAQ,GAAG,SAAU,GAAG;QAC1C,MAAM,OAAO,CAAC;QACd,IAAI,WAAW,IAAI,CAAC,SAAS;QAC7B,IAAI,SAAS,IAAI,CAAC,OAAO;QACzB,IAAI,mBAAmB,IAAA,0KAAmB;QAC1C,IAAI,QAAQ,EAAE;QACd,+BAA+B;QAC/B,IAAI,CAAC,UAAU;YACb,OAAO;QACT;QACA,IAAI,SAAS,IAAI,CAAC,UAAU,CAAC;QAC7B,IAAI,oBAAoB,IAAI,UAAU,KAAK,cAAc;YACvD,IAAA,0KAAmB,IAAG,gBAAgB,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO;YAC/E,OAAO;QACT;QACA,IAAI,cAAc,IAAA,qKAAgB,EAAC,MAAM,CAAC,EAAE,EAAE;QAC9C,MAAM,IAAI,CAAC;YACT,OAAO,MAAM,CAAC,EAAE;YAChB,MAAM;gBACJ,OAAO;gBACP,eAAe;gBACf,eAAe;YACjB;QACF;QACA,IAAI,aAAa,iBAAiB,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,eAAe,EAAE,QAAQ,QAAQ,IAAI,CAAC,wBAAwB,IAAI,IAAI,CAAC,OAAO;QACzI,QAAQ,MAAM,MAAM,CAAC;QACrB,IAAI,cAAc,IAAA,qKAAgB,EAAC,MAAM,CAAC,EAAE,EAAE;QAC9C,MAAM,IAAI,CAAC;YACT,OAAO,MAAM,CAAC,EAAE;YAChB,MAAM;gBACJ,OAAO;gBACP,eAAe;gBACf,eAAe;YACjB;QACF;QACA,IAAI,QAAQ,IAAI,CAAC,UAAU,CAAC;QAC5B,IAAI,iBAAiB,qKAAgB,CAAC,MAAM,GAAG;QAC/C,IAAI,WAAW;QACf,IAAA,yJAAI,EAAC,OAAO,SAAU,IAAI;YACxB,iBAAiB,KAAK,GAAG,CAAC,gBAAgB,IAAA,4JAAO,EAAC,qKAAgB,EAAE,KAAK,IAAI,CAAC,aAAa;YAC3F,WAAW,KAAK,GAAG,CAAC,UAAU,KAAK,IAAI,CAAC,KAAK;QAC/C;QACA,IAAI,kBAAkB;YACpB,IAAA,0KAAmB,IAAG,iBAAiB,CAAC,IAAI,YAAY,EAAE,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,SAAU,IAAI;gBAClG,OAAO,KAAK,KAAK;YACnB,GAAG,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,OAAO;QACvC;QACA,IAAI,oBAAoB,IAAI,UAAU,KAAK,QAAQ;YACjD,IAAA,0KAAmB,IAAG,gBAAgB,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,SAAU,UAAU;gBACnG,gDAAgD;gBAChD,IAAI,oBAAoB,KAAK,GAAG,CAAC,IAAA,4JAAO,EAAC,qKAAgB,EAAE,IAAA,qKAAgB,EAAC,WAAW,IAAI,EAAE,SAAS,IAAA,4JAAO,EAAC,qKAAgB,EAAE,IAAA,qKAAgB,EAAC,WAAW,IAAI,EAAE;gBAClK,IAAI,oBAAoB;gBACxB,IAAK,IAAI,UAAU,GAAG,UAAU,qKAAgB,CAAC,MAAM,EAAE,UAAW;oBAClE,IAAI,CAAC,iCAAiC,qKAAgB,CAAC,QAAQ,EAAE,WAAW,IAAI,EAAE,WAAW,IAAI,EAAE,QAAQ;wBACzG,oBAAoB;wBACpB;oBACF;gBACF;gBACA,IAAI,WAAW,KAAK,GAAG,CAAC,mBAAmB;gBAC3C,IAAI,WAAW,KAAK,GAAG,CAAC,UAAU;gBAClC,OAAO;oBACL,OAAO;oBACP,eAAe,qKAAgB,CAAC,SAAS;oBACzC,eAAe,qKAAgB,CAAC,SAAS;gBAC3C;YACF;QACF;QACA,OAAO;IACT;IACA,UAAU,SAAS,CAAC,cAAc,GAAG,SAAU,GAAG;QAChD,IAAI,SAAS,IAAI,CAAC,SAAS;QAC3B,gDAAgD;QAChD,IAAI,MAAM,CAAC,EAAE,KAAK,MAAM,CAAC,EAAE,EAAE;YAC3B,gBAAgB;YAChB,MAAM,CAAC,EAAE,IAAI,4JAAO;YACpB,MAAM,CAAC,EAAE,IAAI,4JAAO;QACtB;QACA,4DAA4D;QAC5D,IAAI,MAAM,CAAC,EAAE,KAAK,CAAC,YAAY,MAAM,CAAC,EAAE,KAAK,UAAU;YACrD,IAAI,IAAI,IAAI;YACZ,MAAM,CAAC,EAAE,GAAG,CAAC,IAAI,KAAK,EAAE,WAAW,IAAI,EAAE,QAAQ,IAAI,EAAE,OAAO;YAC9D,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,GAAG,4JAAO;QACjC;QACA,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,CAAC,EAAE;QACzC,IAAI,CAAC,aAAa,CAAC,IAAI,WAAW,EAAE,IAAI,WAAW,EAAE,IAAI,WAAW;IACtE;IACA,UAAU,SAAS,CAAC,aAAa,GAAG,SAAU,aAAa,EAAE,WAAW,EAAE,WAAW;QACnF,gBAAgB,iBAAiB;QACjC,IAAI,OAAO,IAAI,CAAC,wBAAwB;QACxC,IAAI,CAAC,eAAe,GAAG,OAAO;QAC9B,IAAI,eAAe,QAAQ,IAAI,CAAC,eAAe,GAAG,aAAa;YAC7D,IAAI,CAAC,eAAe,GAAG;QACzB;QACA,IAAI,eAAe,QAAQ,IAAI,CAAC,eAAe,GAAG,aAAa;YAC7D,IAAI,CAAC,eAAe,GAAG;QACzB;QACA,IAAI,oBAAoB,eAAe,MAAM;QAC7C,IAAI,MAAM,KAAK,GAAG,CAAC,OAAO,gBAAgB,IAAI,CAAC,eAAe,EAAE,GAAG,oBAAoB,oBAAoB;QAC3G,+CAA+C;QAC/C,IAAI,CAAC,SAAS,GAAG,cAAc,CAAC,IAAI,CAAC,EAAE;QACvC,IAAI,CAAC,kBAAkB,GAAG,4KAAgC,CAAC,IAAI,CAAC,SAAS;QACzE,mDAAmD;QACnD,yEAAyE;QACzE,IAAI,CAAC,aAAa,GAAG,cAAc,CAAC,KAAK,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,EAAE;IAC9D;IACA,UAAU,SAAS,CAAC,KAAK,GAAG,SAAU,GAAG;QACvC,sBAAsB;QACtB,OAAO,IAAA,6JAAQ,EAAC,OAAO,MAAM,CAAC,gKAAoB,CAAC;IACrD;IACA,UAAU,SAAS,CAAC,OAAO,GAAG,SAAU,GAAG;QACzC,OAAO,+JAAmB,CAAC,KAAK,IAAI,CAAC,OAAO;IAC9C;IACA,UAAU,SAAS,CAAC,SAAS,GAAG,SAAU,GAAG;QAC3C,OAAO,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,IAAI,CAAC,OAAO;IACrD;IACA,UAAU,SAAS,CAAC,KAAK,GAAG,SAAU,GAAG;QACvC,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,OAAO;IACjD;IACA,UAAU,IAAI,GAAG;IACjB,OAAO;AACT,EAAE,iKAAa;AACf;;;;;CAKC,GACD,IAAI,iBAAiB;IACrB,4CAA4C;IAC5C;QAAC;QAAU,+JAAU;KAAC;IAAE;QAAC;QAAU,+JAAU;KAAC;IAAE;QAAC;QAAQ,6JAAQ;KAAC;IAAE;QAAC;QAAe,6JAAQ,GAAG;KAAE;IAAE;QAAC;QAAY,6JAAQ,GAAG;KAAG;IAAE;QAAC;QAAO,4JAAO,GAAG;KAAI;IAAE;QAAC;QAAa,4JAAO,GAAG;KAAI;IAAE;QAAC;QAAQ,4JAAO,GAAG;KAAE;IAAE;QAAC;QAAS,4JAAO,GAAG;KAAG;IAAE;QAAC;QAAW,4JAAO,GAAG;KAAG;IAAE;QAAC;QAAa,6JAAQ,GAAG;KAAE;IAAE;QAAC;QAAQ,6JAAQ;KAAC,CAAC,KAAK;CACrT;AACD,SAAS,iCAAiC,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK;IACnE,OAAO,IAAA,8JAAS,EAAC,IAAI,KAAK,SAAS,MAAM,OAAO,OAAO,OAAO,IAAA,8JAAS,EAAC,IAAI,KAAK,SAAS,MAAM,OAAO,OAAO;AAChH;AACA,4BAA4B;AAC5B,6BAA6B;AAC7B,sBAAsB;AACtB,sBAAsB;AACtB,qBAAqB;AACrB,eAAe;AACf,yDAAyD;AACzD,yDAAyD;AACzD,kDAAkD;AAClD,kDAAkD;AAClD,oDAAoD;AACpD,SAAS;AACT,+CAA+C;AAC/C,2EAA2E;AAC3E,uEAAuE;AACvE,iEAAiE;AACjE,8DAA8D;AAC9D,wEAAwE;AACxE,8DAA8D;AAC9D,mEAAmE;AACnE,qEAAqE;AACrE,+EAA+E;AAC/E,sBAAsB;AACtB,uBAAuB;AACvB,mCAAmC;AACnC,wBAAwB;AACxB,oCAAoC;AACpC,sBAAsB;AACtB,kCAAkC;AAClC,uBAAuB;AACvB,mCAAmC;AACnC,yBAAyB;AACzB,qCAAqC;AACrC,yBAAyB;AACzB,qCAAqC;AACrC,8BAA8B;AAC9B,0CAA0C;AAC1C,QAAQ;AACR,IAAI;AACJ,+BAA+B;AAC/B,kCAAkC;AAClC,gCAAgC;AAChC,6BAA6B;AAC7B,+BAA+B;AAC/B,mCAAmC;AACnC,mCAAmC;AACnC,4CAA4C;AAC5C,KAAK;AACL,kCAAkC;AAClC,sCAAsC;AACtC,oCAAoC;AACpC,iCAAiC;AACjC,mCAAmC;AACnC,uCAAuC;AACvC,uCAAuC;AACvC,gDAAgD;AAChD,KAAK;AACL,oFAAoF;AACpF,wBAAwB;AACxB,8CAA8C;AAC9C,uBAAuB;AACvB,yFAAyF;AACzF,qBAAqB;AACrB,wBAAwB;AACxB,mFAAmF;AACnF,qBAAqB;AACrB,sBAAsB;AACtB,iFAAiF;AACjF,qBAAqB;AACrB,uBAAuB;AACvB,mFAAmF;AACnF,qBAAqB;AACrB,yBAAyB;AACzB,uFAAuF;AACvF,qBAAqB;AACrB,yBAAyB;AACzB,uFAAuF;AACvF,qBAAqB;AACrB,8BAA8B;AAC9B,iGAAiG;AACjG,qBAAqB;AACrB,QAAQ;AACR,6BAA6B;AAC7B,IAAI;AACJ,yDAAyD;AACzD,0DAA0D;AAC1D,8FAA8F;AAC9F,SAAS,gBAAgB,cAAc,EAAE,WAAW;IAClD,kBAAkB,4JAAO;IACzB,OAAO,iBAAiB,KAAK,KAE3B,iBAAiB,MAAM,EAAE,wBAAwB;OACjD,iBAAiB,MAAM,IAAI,iBAAiB,MAAM,IAAI;AAC1D;AACA,SAAS,iBAAiB,cAAc;IACtC,IAAI,mBAAmB,KAAK,4JAAO;IACnC,kBAAkB;IAClB,OAAO,iBAAiB,IAAI,IAAI,iBAAiB,IAAI,IAAI,iBAAiB,IAAI,IAAI;AACpF;AACA,SAAS,gBAAgB,cAAc;IACrC,kBAAkB,6JAAQ;IAC1B,OAAO,iBAAiB,KAAK,KAAK,iBAAiB,IAAI,IAAI,iBAAiB,MAAM,IAAI,iBAAiB,IAAI,IAAI;AACjH;AACA,SAAS,6BAA6B,cAAc,EAAE,SAAS;IAC7D,kBAAkB,YAAY,+JAAU,GAAG,+JAAU;IACrD,OAAO,iBAAiB,KAAK,KAAK,iBAAiB,KAAK,KAAK,iBAAiB,KAAK,KAAK,iBAAiB,KAAK,KAAK,iBAAiB,IAAI,IAAI,iBAAiB,IAAI,IAAI;AACvK;AACA,SAAS,wBAAwB,cAAc;IAC7C,OAAO,2JAAe,CAAC,gBAAgB;AACzC;AACA,gFAAgF;AAChF,mCAAmC;AACnC,SAAS,wBAAwB,SAAS,EAAE,QAAQ,EAAE,KAAK;IACzD,IAAI,eAAe,KAAK,GAAG,CAAC,GAAG,IAAA,4JAAO,EAAC,qKAAgB,EAAE,YAAY;IACrE,OAAO,IAAA,8JAAS,EAAC,IAAI,KAAK,YAAY,qKAAgB,CAAC,aAAa,EAAE,OAAO,OAAO;AACtF;AACA,SAAS,2BAA2B,aAAa,EAAE,kBAAkB;IACnE,IAAI,UAAU,IAAI,KAAK;IACvB,OAAO,CAAC,cAAc,CAAC;IACvB,IAAI,UAAU,QAAQ,OAAO;IAC7B,OAAO,CAAC,cAAc,CAAC,IAAI;IAC3B,IAAI,qBAAqB,QAAQ,OAAO,KAAK;IAC7C,OAAO,SAAU,OAAO,EAAE,WAAW;QACnC,gEAAgE;QAChE,iDAAiD;QACjD,OAAO,KAAK,GAAG,CAAC,GAAG,KAAK,KAAK,CAAC,CAAC,cAAc,OAAO,IAAI;IAC1D;AACF;AACA,SAAS,iBAAiB,cAAc,EAAE,cAAc,EAAE,KAAK,EAAE,MAAM,EAAE,oBAAoB,EAAE,MAAM;IACnG,IAAI,YAAY;IAChB,IAAI,YAAY,8JAAS;IACzB,IAAI,OAAO;IACX,SAAS,eAAe,QAAQ,EAAE,YAAY,EAAE,YAAY,EAAE,aAAa,EAAE,aAAa,EAAE,MAAM,EAAE,GAAG;QACrG,IAAI,uBAAuB,2BAA2B,eAAe;QACrE,IAAI,WAAW;QACf,IAAI,OAAO,IAAI,KAAK;QACpB,gBAAgB;QAChB,0CAA0C;QAC1C,IAAI;QACJ,MAAO,WAAW,gBAAgB,YAAY,MAAM,CAAC,EAAE,CAAE;YACvD,IAAI,IAAI,CAAC;gBACP,OAAO;YACT;YACA,IAAI,SAAS,WAAW;gBACtB,wCAA2C;oBACzC,IAAA,wJAAI,EAAC;gBACP;gBACA;YACF;YACA,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,KAAK;YAC5C,WAAW,KAAK,OAAO;YACvB,IAAI,QAAQ;gBACV,IAAI,eAAe,OAAO,oBAAoB,CAAC,UAAU;gBACzD,IAAI,eAAe,GAAG;oBACpB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,KAAK,eAAe;oBAC3D,WAAW,KAAK,OAAO;gBACzB;YACF;QACF;QACA,iGAAiG;QACjG,IAAI,IAAI,CAAC;YACP,OAAO;YACP,QAAQ;QACV;IACF;IACA,SAAS,cAAc,QAAQ,EAAE,cAAc,EAAE,UAAU;QACzD,IAAI,gBAAgB,EAAE;QACtB,IAAI,eAAe,CAAC,eAAe,MAAM;QACzC,IAAI,iCAAiC,IAAA,uKAAkB,EAAC,WAAW,MAAM,CAAC,EAAE,EAAE,MAAM,CAAC,EAAE,EAAE,QAAQ;YAC/F;QACF;QACA,IAAI,cAAc;YAChB,iBAAiB;gBAAC;oBAChB,OAAO,wBAAwB,MAAM,CAAC,EAAE,EAAE,UAAU;gBACtD;gBAAG;oBACD,OAAO,MAAM,CAAC,EAAE;gBAClB;aAAE;QACJ;QACA,IAAK,IAAI,IAAI,GAAG,IAAI,eAAe,MAAM,GAAG,GAAG,IAAK;YAClD,IAAI,YAAY,cAAc,CAAC,EAAE,CAAC,KAAK;YACvC,IAAI,UAAU,cAAc,CAAC,IAAI,EAAE,CAAC,KAAK;YACzC,IAAI,cAAc,SAAS;gBACzB;YACF;YACA,IAAI,WAAW,KAAK;YACpB,IAAI,aAAa,KAAK;YACtB,IAAI,aAAa,KAAK;YACtB,IAAI,SAAS;YACb,OAAQ;gBACN,KAAK;oBACH,WAAW,KAAK,GAAG,CAAC,GAAG,KAAK,KAAK,CAAC,iBAAiB,4JAAO,GAAG;oBAC7D,aAAa,IAAA,uKAAkB,EAAC;oBAChC,aAAa,IAAA,uKAAkB,EAAC;oBAChC;gBACF,KAAK;gBACL,KAAK;gBACL,KAAK;oBACH,WAAW,iBAAiB;oBAC5B,aAAa,IAAA,oKAAe,EAAC;oBAC7B,aAAa,IAAA,oKAAe,EAAC;oBAC7B;gBACF,KAAK;gBACL,KAAK;gBACL,KAAK;oBACH,WAAW,gBAAgB,gBAAgB,KAAK,uCAAuC;oBACvF,aAAa,IAAA,mKAAc,EAAC;oBAC5B,aAAa,IAAA,mKAAc,EAAC;oBAC5B,SAAS;oBACT;gBACF,KAAK;gBACL,KAAK;gBACL,KAAK;oBACH,WAAW,gBAAgB;oBAC3B,aAAa,IAAA,oKAAe,EAAC;oBAC7B,aAAa,IAAA,oKAAe,EAAC;oBAC7B;gBACF,KAAK;oBACH,WAAW,6BAA6B,gBAAgB;oBACxD,aAAa,IAAA,sKAAiB,EAAC;oBAC/B,aAAa,IAAA,sKAAiB,EAAC;oBAC/B;gBACF,KAAK;oBACH,WAAW,6BAA6B,gBAAgB;oBACxD,aAAa,IAAA,sKAAiB,EAAC;oBAC/B,aAAa,IAAA,sKAAiB,EAAC;oBAC/B;gBACF,KAAK;oBACH,WAAW,wBAAwB;oBACnC,aAAa,IAAA,2KAAsB,EAAC;oBACpC,aAAa,IAAA,2KAAsB,EAAC;oBACpC;YACJ;YACA,mFAAmF;YACnF,mFAAmF;YACnF,kDAAkD;YAClD,IAAI,WAAW,MAAM,CAAC,EAAE,IAAI,aAAa,MAAM,CAAC,EAAE,EAAE;gBAClD,eAAe,UAAU,WAAW,SAAS,YAAY,YAAY,QAAQ;YAC/E;YACA,IAAI,aAAa,UAAU,WAAW,MAAM,GAAG,KAAK,MAAM,GAAG;gBAC3D,wCAAwC;gBACxC,WAAW,OAAO,CAAC;oBACjB,OAAO,UAAU,CAAC,EAAE,CAAC,KAAK,GAAG;gBAC/B;YACF;QACF;QACA,IAAK,IAAI,IAAI,GAAG,IAAI,cAAc,MAAM,EAAE,IAAK;YAC7C,WAAW,IAAI,CAAC,aAAa,CAAC,EAAE;QAClC;IACF;IACA,IAAI,cAAc,EAAE;IACpB,IAAI,oBAAoB,EAAE;IAC1B,IAAI,YAAY;IAChB,IAAI,qBAAqB;IACzB,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,EAAE,EAAG;QACzC,IAAI,kBAAkB,IAAA,uKAAkB,EAAC,SAAS,CAAC,EAAE;QACrD,IAAI,CAAC,IAAA,sKAAiB,EAAC,SAAS,CAAC,EAAE,GAAG;YAEpC;QACF;QACA,cAAc,SAAS,CAAC,EAAE,EAAE,WAAW,CAAC,YAAY,MAAM,GAAG,EAAE,IAAI,EAAE,EAAE;QACvE,IAAI,sBAAsB,SAAS,CAAC,IAAI,EAAE,GAAG,IAAA,uKAAkB,EAAC,SAAS,CAAC,IAAI,EAAE,IAAI;QACpF,IAAI,oBAAoB,qBAAqB;YAC3C,IAAI,kBAAkB,MAAM,EAAE;gBAC5B,qBAAqB;gBACrB,2DAA2D;gBAC3D,kBAAkB,IAAI,CAAC,SAAU,CAAC,EAAE,CAAC;oBACnC,OAAO,EAAE,KAAK,GAAG,EAAE,KAAK;gBAC1B;gBACA,IAAI,6BAA6B,EAAE;gBACnC,IAAK,IAAI,MAAM,GAAG,MAAM,kBAAkB,MAAM,EAAE,EAAE,IAAK;oBACvD,IAAI,YAAY,iBAAiB,CAAC,IAAI,CAAC,KAAK;oBAC5C,IAAI,QAAQ,KAAK,iBAAiB,CAAC,MAAM,EAAE,CAAC,KAAK,KAAK,WAAW;wBAC/D,2BAA2B,IAAI,CAAC,iBAAiB,CAAC,IAAI;wBACtD,IAAI,aAAa,MAAM,CAAC,EAAE,IAAI,aAAa,MAAM,CAAC,EAAE,EAAE;4BACpD;wBACF;oBACF;gBACF;gBACA,IAAI,gBAAgB,uBAAuB;gBAC3C,8DAA8D;gBAC9D,IAAI,YAAY,gBAAgB,OAAO,qBAAqB,gBAAgB,KAAK;oBAC/E;gBACF;gBACA,6CAA6C;gBAC7C,YAAY,IAAI,CAAC;gBACjB,IAAI,YAAY,iBAAiB,mBAAmB,SAAS,CAAC,EAAE,EAAE;oBAChE;gBACF;YACF;YACA,oCAAoC;YACpC,oBAAoB,EAAE;QACxB;IACF;IACA,IAAI,sBAAsB,IAAA,2JAAM,EAAC,IAAA,wJAAG,EAAC,aAAa,SAAU,UAAU;QACpE,OAAO,IAAA,2JAAM,EAAC,YAAY,SAAU,IAAI;YACtC,OAAO,KAAK,KAAK,IAAI,MAAM,CAAC,EAAE,IAAI,KAAK,KAAK,IAAI,MAAM,CAAC,EAAE,IAAI,CAAC,KAAK,MAAM;QAC3E;IACF,IAAI,SAAU,UAAU;QACtB,OAAO,WAAW,MAAM,GAAG;IAC7B;IACA,IAAI,QAAQ,EAAE;IACd,IAAI,WAAW,oBAAoB,MAAM,GAAG;IAC5C,IAAK,IAAI,IAAI,GAAG,IAAI,oBAAoB,MAAM,EAAE,EAAE,EAAG;QACnD,IAAI,aAAa,mBAAmB,CAAC,EAAE;QACvC,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,EAAE,EAAG;YAC1C,IAAI,OAAO,IAAA,qKAAgB,EAAC,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE;YACjD,MAAM,IAAI,CAAC;gBACT,OAAO,UAAU,CAAC,EAAE,CAAC,KAAK;gBAC1B,MAAM;oBACJ,OAAO,WAAW;oBAClB,eAAe;oBACf,eAAe;gBACjB;YACF;QACF;IACF;IACA,MAAM,IAAI,CAAC,SAAU,CAAC,EAAE,CAAC;QACvB,OAAO,EAAE,KAAK,GAAG,EAAE,KAAK;IAC1B;IACA,oBAAoB;IACpB,IAAI,SAAS,EAAE;IACf,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,EAAE,EAAG;QACrC,IAAI,MAAM,KAAK,KAAK,CAAC,EAAE,CAAC,KAAK,KAAK,KAAK,CAAC,IAAI,EAAE,CAAC,KAAK,EAAE;YACpD,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE;QACtB;IACF;IACA,OAAO;AACT;AACA,8JAAK,CAAC,aAAa,CAAC;uCACL","ignoreList":[0]}},
    {"offset": {"line": 1532, "column": 0}, "map": {"version":3,"sources":["file:///Users/madhusudhan/Documents/autosense-analytics/frontend/node_modules/echarts/lib/scale/Log.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport Scale from './Scale.js';\nimport * as numberUtil from '../util/number.js';\n// Use some method of IntervalScale\nimport IntervalScale from './Interval.js';\nimport { getIntervalPrecision, logTransform } from './helper.js';\nimport { getScaleBreakHelper } from './break.js';\nvar fixRound = numberUtil.round;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar mathPow = Math.pow;\nvar mathLog = Math.log;\nvar LogScale = /** @class */function (_super) {\n  __extends(LogScale, _super);\n  function LogScale() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = 'log';\n    _this.base = 10;\n    _this._originalScale = new IntervalScale();\n    return _this;\n  }\n  /**\n   * @param Whether expand the ticks to niced extent.\n   */\n  LogScale.prototype.getTicks = function (opt) {\n    opt = opt || {};\n    var extent = this._extent.slice();\n    var originalExtent = this._originalScale.getExtent();\n    var ticks = _super.prototype.getTicks.call(this, opt);\n    var base = this.base;\n    var originalBreaks = this._originalScale._innerGetBreaks();\n    var scaleBreakHelper = getScaleBreakHelper();\n    return zrUtil.map(ticks, function (tick) {\n      var val = tick.value;\n      var roundingCriterion = null;\n      var powVal = mathPow(base, val);\n      // Fix #4158\n      if (val === extent[0] && this._fixMin) {\n        roundingCriterion = originalExtent[0];\n      } else if (val === extent[1] && this._fixMax) {\n        roundingCriterion = originalExtent[1];\n      }\n      var vBreak;\n      if (scaleBreakHelper) {\n        var transformed = scaleBreakHelper.getTicksLogTransformBreak(tick, base, originalBreaks, fixRoundingError);\n        vBreak = transformed.vBreak;\n        if (roundingCriterion == null) {\n          roundingCriterion = transformed.brkRoundingCriterion;\n        }\n      }\n      if (roundingCriterion != null) {\n        powVal = fixRoundingError(powVal, roundingCriterion);\n      }\n      return {\n        value: powVal,\n        \"break\": vBreak\n      };\n    }, this);\n  };\n  LogScale.prototype._getNonTransBreaks = function () {\n    return this._originalScale._innerGetBreaks();\n  };\n  LogScale.prototype.setExtent = function (start, end) {\n    this._originalScale.setExtent(start, end);\n    var loggedExtent = logTransform(this.base, [start, end]);\n    _super.prototype.setExtent.call(this, loggedExtent[0], loggedExtent[1]);\n  };\n  /**\n   * @return {number} end\n   */\n  LogScale.prototype.getExtent = function () {\n    var base = this.base;\n    var extent = _super.prototype.getExtent.call(this);\n    extent[0] = mathPow(base, extent[0]);\n    extent[1] = mathPow(base, extent[1]);\n    // Fix #4158\n    var originalExtent = this._originalScale.getExtent();\n    this._fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n    this._fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n    return extent;\n  };\n  LogScale.prototype.unionExtentFromData = function (data, dim) {\n    this._originalScale.unionExtentFromData(data, dim);\n    var loggedOther = logTransform(this.base, data.getApproximateExtent(dim), true);\n    this._innerUnionExtent(loggedOther);\n  };\n  /**\n   * Update interval and extent of intervals for nice ticks\n   * @param approxTickNum default 10 Given approx tick number\n   */\n  LogScale.prototype.calcNiceTicks = function (approxTickNum) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent.slice();\n    var span = this._getExtentSpanWithBreaks();\n    if (!isFinite(span) || span <= 0) {\n      return;\n    }\n    var interval = numberUtil.quantity(span);\n    var err = approxTickNum / span * interval;\n    // Filter ticks to get closer to the desired count.\n    if (err <= 0.5) {\n      interval *= 10;\n    }\n    // Interval should be integer\n    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n      interval *= 10;\n    }\n    var niceExtent = [fixRound(mathCeil(extent[0] / interval) * interval), fixRound(mathFloor(extent[1] / interval) * interval)];\n    this._interval = interval;\n    this._intervalPrecision = getIntervalPrecision(interval);\n    this._niceExtent = niceExtent;\n  };\n  LogScale.prototype.calcNiceExtent = function (opt) {\n    _super.prototype.calcNiceExtent.call(this, opt);\n    this._fixMin = opt.fixMin;\n    this._fixMax = opt.fixMax;\n  };\n  LogScale.prototype.contain = function (val) {\n    val = mathLog(val) / mathLog(this.base);\n    return _super.prototype.contain.call(this, val);\n  };\n  LogScale.prototype.normalize = function (val) {\n    val = mathLog(val) / mathLog(this.base);\n    return _super.prototype.normalize.call(this, val);\n  };\n  LogScale.prototype.scale = function (val) {\n    val = _super.prototype.scale.call(this, val);\n    return mathPow(this.base, val);\n  };\n  LogScale.prototype.setBreaksFromOption = function (breakOptionList) {\n    var scaleBreakHelper = getScaleBreakHelper();\n    if (!scaleBreakHelper) {\n      return;\n    }\n    var _a = scaleBreakHelper.logarithmicParseBreaksFromOption(breakOptionList, this.base, zrUtil.bind(this.parse, this)),\n      parsedOriginal = _a.parsedOriginal,\n      parsedLogged = _a.parsedLogged;\n    this._originalScale._innerSetBreak(parsedOriginal);\n    this._innerSetBreak(parsedLogged);\n  };\n  LogScale.type = 'log';\n  return LogScale;\n}(IntervalScale);\nfunction fixRoundingError(val, originalVal) {\n  return fixRound(val, numberUtil.getPrecision(originalVal));\n}\nScale.registerClass(LogScale);\nexport default LogScale;"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1733, "column": 0}, "map": {"version":3,"sources":["file:///Users/madhusudhan/Documents/autosense-analytics/frontend/node_modules/echarts/lib/scale/breakImpl.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, clone, each, find, isString, map, trim } from 'zrender/lib/core/util.js';\nimport { error } from '../util/log.js';\nimport { registerScaleBreakHelperImpl } from './break.js';\nimport { round as fixRound } from '../util/number.js';\n/**\n * @caution\n *  Must not export anything except `installScaleBreakHelper`\n */\nvar ScaleBreakContextImpl = /** @class */function () {\n  function ScaleBreakContextImpl() {\n    // [CAVEAT]: Should set only by `ScaleBreakContext#setBreaks`!\n    this.breaks = [];\n    // [CAVEAT]: Should update only by `ScaleBreakContext#update`!\n    // They are the values that scaleExtent[0] and scaleExtent[1] are mapped to a numeric axis\n    // that breaks are applied, primarily for optimization of `Scale#normalize`.\n    this._elapsedExtent = [Infinity, -Infinity];\n  }\n  ScaleBreakContextImpl.prototype.setBreaks = function (parsed) {\n    // @ts-ignore\n    this.breaks = parsed.breaks;\n  };\n  /**\n   * [CAVEAT]: Must be called immediately each time scale extent and breaks are updated!\n   */\n  ScaleBreakContextImpl.prototype.update = function (scaleExtent) {\n    updateAxisBreakGapReal(this, scaleExtent);\n    var elapsedExtent = this._elapsedExtent;\n    elapsedExtent[0] = this.elapse(scaleExtent[0]);\n    elapsedExtent[1] = this.elapse(scaleExtent[1]);\n  };\n  ScaleBreakContextImpl.prototype.hasBreaks = function () {\n    return !!this.breaks.length;\n  };\n  /**\n   * When iteratively generating ticks by nice interval, currently the `interval`, which is\n   * calculated by break-elapsed extent span, is probably very small comparing to the original\n   * extent, leading to a large number of iteration and tick generation, even over `safeLimit`.\n   * Thus stepping over breaks is necessary in that loop.\n   *\n   * \"Nice\" should be ensured on ticks when step over the breaks. Thus this method returns\n   * a integer multiple of the \"nice tick interval\".\n   *\n   * This method does little work; it is just for unifying and restricting the behavior.\n   */\n  ScaleBreakContextImpl.prototype.calcNiceTickMultiple = function (tickVal, estimateNiceMultiple) {\n    for (var idx = 0; idx < this.breaks.length; idx++) {\n      var brk = this.breaks[idx];\n      if (brk.vmin < tickVal && tickVal < brk.vmax) {\n        var multiple = estimateNiceMultiple(tickVal, brk.vmax);\n        if (process.env.NODE_ENV !== 'production') {\n          // If not, it may cause dead loop or not nice tick.\n          assert(multiple >= 0 && Math.round(multiple) === multiple);\n        }\n        return multiple;\n      }\n    }\n    return 0;\n  };\n  ScaleBreakContextImpl.prototype.getExtentSpan = function () {\n    return this._elapsedExtent[1] - this._elapsedExtent[0];\n  };\n  ScaleBreakContextImpl.prototype.normalize = function (val) {\n    var elapsedSpan = this._elapsedExtent[1] - this._elapsedExtent[0];\n    // The same logic as `Scale#normalize`.\n    if (elapsedSpan === 0) {\n      return 0.5;\n    }\n    return (this.elapse(val) - this._elapsedExtent[0]) / elapsedSpan;\n  };\n  ScaleBreakContextImpl.prototype.scale = function (val) {\n    return this.unelapse(val * (this._elapsedExtent[1] - this._elapsedExtent[0]) + this._elapsedExtent[0]);\n  };\n  /**\n   * Suppose:\n   *    AXIS_BREAK_LAST_BREAK_END_BASE: 0\n   *    AXIS_BREAK_ELAPSED_BASE: 0\n   *    breaks: [\n   *        {start: -400, end: -300, gap: 27},\n   *        {start: -100, end: 100, gap: 10},\n   *        {start: 200, end: 400, gap: 300},\n   *    ]\n   * The mapping will be:\n   *        |        |\n   *    400 +   ->   +  237\n   *     |  |        |   |  (gap: 300)\n   *    200 +   ->   + -63\n   *        |        |\n   *    100 +   ->   + -163\n   *     |  |        |   |  (gap: 10)\n   *   -100 +   ->   + -173\n   *        |        |\n   *   -300 +   ->   + -373\n   *     |  |        |   |  (gap: 27)\n   *   -400 +   ->   + -400\n   *        |        |\n   *   origianl     elapsed\n   *\n   * Note:\n   *   The mapping has nothing to do with \"scale extent\".\n   */\n  ScaleBreakContextImpl.prototype.elapse = function (val) {\n    // If the value is in the break, return the normalized value in the break\n    var elapsedVal = AXIS_BREAK_ELAPSED_BASE;\n    var lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;\n    var stillOver = true;\n    for (var i = 0; i < this.breaks.length; i++) {\n      var brk = this.breaks[i];\n      if (val <= brk.vmax) {\n        if (val > brk.vmin) {\n          elapsedVal += brk.vmin - lastBreakEnd + (val - brk.vmin) / (brk.vmax - brk.vmin) * brk.gapReal;\n        } else {\n          elapsedVal += val - lastBreakEnd;\n        }\n        lastBreakEnd = brk.vmax;\n        stillOver = false;\n        break;\n      }\n      elapsedVal += brk.vmin - lastBreakEnd + brk.gapReal;\n      lastBreakEnd = brk.vmax;\n    }\n    if (stillOver) {\n      elapsedVal += val - lastBreakEnd;\n    }\n    return elapsedVal;\n  };\n  ScaleBreakContextImpl.prototype.unelapse = function (elapsedVal) {\n    var lastElapsedEnd = AXIS_BREAK_ELAPSED_BASE;\n    var lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;\n    var stillOver = true;\n    var unelapsedVal = 0;\n    for (var i = 0; i < this.breaks.length; i++) {\n      var brk = this.breaks[i];\n      var elapsedStart = lastElapsedEnd + brk.vmin - lastBreakEnd;\n      var elapsedEnd = elapsedStart + brk.gapReal;\n      if (elapsedVal <= elapsedEnd) {\n        if (elapsedVal > elapsedStart) {\n          unelapsedVal = brk.vmin + (elapsedVal - elapsedStart) / (elapsedEnd - elapsedStart) * (brk.vmax - brk.vmin);\n        } else {\n          unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;\n        }\n        lastBreakEnd = brk.vmax;\n        stillOver = false;\n        break;\n      }\n      lastElapsedEnd = elapsedEnd;\n      lastBreakEnd = brk.vmax;\n    }\n    if (stillOver) {\n      unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;\n    }\n    return unelapsedVal;\n  };\n  return ScaleBreakContextImpl;\n}();\n;\nfunction createScaleBreakContext() {\n  return new ScaleBreakContextImpl();\n}\n// Both can start with any finite value, and are not necessaryily equal. But they need to\n// be the same in `axisBreakElapse` and `axisBreakUnelapse` respectively.\nvar AXIS_BREAK_ELAPSED_BASE = 0;\nvar AXIS_BREAK_LAST_BREAK_END_BASE = 0;\n/**\n * `gapReal` in brkCtx.breaks will be calculated.\n */\nfunction updateAxisBreakGapReal(brkCtx, scaleExtent) {\n  // Considered the effect:\n  //  - Use dataZoom to move some of the breaks outside the extent.\n  //  - Some scenarios that `series.clip: false`.\n  //\n  // How to calculate `prctBrksGapRealSum`:\n  //  Based on the formula:\n  //      xxx.span = brk.vmax - brk.vmin\n  //      xxx.tpPrct.val / xxx.tpAbs.val means ParsedAxisBreak['gapParsed']['val']\n  //      .S/.E means a break that is semi in scaleExtent[0] or scaleExtent[1]\n  //      valP = (\n  //          + (fullyInExtBrksSum.tpAbs.gapReal - fullyInExtBrksSum.tpAbs.span)\n  //          + (semiInExtBrk.S.tpAbs.gapReal - semiInExtBrk.S.tpAbs.span) * semiInExtBrk.S.tpAbs.inExtFrac\n  //          + (semiInExtBrk.E.tpAbs.gapReal - semiInExtBrk.E.tpAbs.span) * semiInExtBrk.E.tpAbs.inExtFrac\n  //      )\n  //      valQ = (\n  //          - fullyInExtBrksSum.tpPrct.span\n  //          - semiInExtBrk.S.tpPrct.span * semiInExtBrk.S.tpPrct.inExtFrac\n  //          - semiInExtBrk.E.tpPrct.span * semiInExtBrk.E.tpPrct.inExtFrac\n  //      )\n  //      gapPrctSum = sum(xxx.tpPrct.val)\n  //      gapPrctSum = prctBrksGapRealSum / (\n  //          + (scaleExtent[1] - scaleExtent[0]) + valP + valQ\n  //          + fullyInExtBrksSum.tpPrct.gapReal\n  //          + semiInExtBrk.S.tpPrct.gapReal * semiInExtBrk.S.tpPrct.inExtFrac\n  //          + semiInExtBrk.E.tpPrct.gapReal * semiInExtBrk.E.tpPrct.inExtFrac\n  //      )\n  //  Assume:\n  //      xxx.tpPrct.gapReal = xxx.tpPrct.val / gapPrctSum * prctBrksGapRealSum\n  //         (NOTE: This is not accurate when semi-in-extent break exist because its\n  //         proportion is not linear, but this assumption approximately works.)\n  //  Derived as follows:\n  //      prctBrksGapRealSum = gapPrctSum * ( (scaleExtent[1] - scaleExtent[0]) + valP + valQ )\n  //          / (1\n  //              - fullyInExtBrksSum.tpPrct.val\n  //              - semiInExtBrk.S.tpPrct.val * semiInExtBrk.S.tpPrct.inExtFrac\n  //              - semiInExtBrk.E.tpPrct.val * semiInExtBrk.E.tpPrct.inExtFrac\n  //          )\n  var gapPrctSum = 0;\n  var fullyInExtBrksSum = {\n    tpAbs: {\n      span: 0,\n      val: 0\n    },\n    tpPrct: {\n      span: 0,\n      val: 0\n    }\n  };\n  var init = function () {\n    return {\n      has: false,\n      span: NaN,\n      inExtFrac: NaN,\n      val: NaN\n    };\n  };\n  var semiInExtBrk = {\n    S: {\n      tpAbs: init(),\n      tpPrct: init()\n    },\n    E: {\n      tpAbs: init(),\n      tpPrct: init()\n    }\n  };\n  each(brkCtx.breaks, function (brk) {\n    var gapParsed = brk.gapParsed;\n    if (gapParsed.type === 'tpPrct') {\n      gapPrctSum += gapParsed.val;\n    }\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (clampedBrk) {\n      var vminClamped = clampedBrk.vmin !== brk.vmin;\n      var vmaxClamped = clampedBrk.vmax !== brk.vmax;\n      var clampedSpan = clampedBrk.vmax - clampedBrk.vmin;\n      if (vminClamped && vmaxClamped) {\n        // Do nothing, which simply makes the result `gapReal` cover the entire scaleExtent.\n        // This transform is not consistent with the other cases but practically works.\n      } else if (vminClamped || vmaxClamped) {\n        var sOrE = vminClamped ? 'S' : 'E';\n        semiInExtBrk[sOrE][gapParsed.type].has = true;\n        semiInExtBrk[sOrE][gapParsed.type].span = clampedSpan;\n        semiInExtBrk[sOrE][gapParsed.type].inExtFrac = clampedSpan / (brk.vmax - brk.vmin);\n        semiInExtBrk[sOrE][gapParsed.type].val = gapParsed.val;\n      } else {\n        fullyInExtBrksSum[gapParsed.type].span += clampedSpan;\n        fullyInExtBrksSum[gapParsed.type].val += gapParsed.val;\n      }\n    }\n  });\n  var prctBrksGapRealSum = gapPrctSum * (0 + (scaleExtent[1] - scaleExtent[0]) + (fullyInExtBrksSum.tpAbs.val - fullyInExtBrksSum.tpAbs.span) + (semiInExtBrk.S.tpAbs.has ? (semiInExtBrk.S.tpAbs.val - semiInExtBrk.S.tpAbs.span) * semiInExtBrk.S.tpAbs.inExtFrac : 0) + (semiInExtBrk.E.tpAbs.has ? (semiInExtBrk.E.tpAbs.val - semiInExtBrk.E.tpAbs.span) * semiInExtBrk.E.tpAbs.inExtFrac : 0) - fullyInExtBrksSum.tpPrct.span - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.span * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.span * semiInExtBrk.E.tpPrct.inExtFrac : 0)) / (1 - fullyInExtBrksSum.tpPrct.val - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.val * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.val * semiInExtBrk.E.tpPrct.inExtFrac : 0));\n  each(brkCtx.breaks, function (brk) {\n    var gapParsed = brk.gapParsed;\n    if (gapParsed.type === 'tpPrct') {\n      brk.gapReal = gapPrctSum !== 0\n      // prctBrksGapRealSum is supposed to be non-negative but add a safe guard\n      ? Math.max(prctBrksGapRealSum, 0) * gapParsed.val / gapPrctSum : 0;\n    }\n    if (gapParsed.type === 'tpAbs') {\n      brk.gapReal = gapParsed.val;\n    }\n    if (brk.gapReal == null) {\n      brk.gapReal = 0;\n    }\n  });\n}\nfunction pruneTicksByBreak(pruneByBreak, ticks, breaks, getValue, interval, scaleExtent) {\n  if (pruneByBreak === 'no') {\n    return;\n  }\n  each(breaks, function (brk) {\n    // break.vmin/vmax that out of extent must not impact the visible of\n    // normal ticks and labels.\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (!clampedBrk) {\n      return;\n    }\n    // Remove some normal ticks to avoid zigzag shapes overlapping with split lines\n    // and to avoid break labels overlapping with normal tick labels (thouth it can\n    // also be avoided by `axisLabel.hideOverlap`).\n    // It's OK to O(n^2) since the number of `ticks` are small.\n    for (var j = ticks.length - 1; j >= 0; j--) {\n      var tick = ticks[j];\n      var val = getValue(tick);\n      // 1. Ensure there is no ticks inside `break.vmin` and `break.vmax`.\n      // 2. Use an empirically gap value here. Theoritically `zigzagAmplitude` is\n      //  supposed to be involved to provide better precision but it will brings\n      //  more complexity. The empirically gap value is conservative because break\n      //  labels and normal tick lables are prone to overlapping.\n      var gap = interval * 3 / 4;\n      if (val > clampedBrk.vmin - gap && val < clampedBrk.vmax + gap && (pruneByBreak !== 'preserve_extent_bound' || val !== scaleExtent[0] && val !== scaleExtent[1])) {\n        ticks.splice(j, 1);\n      }\n    }\n  });\n}\nfunction addBreaksToTicks(\n// The input ticks should be in accending order.\nticks, breaks, scaleExtent,\n// Keep the break ends at the same level to avoid an awkward appearance.\ngetTimeProps) {\n  each(breaks, function (brk) {\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (!clampedBrk) {\n      return;\n    }\n    // - When neight `break.vmin` nor `break.vmax` is in scale extent,\n    //  break label should not be displayed and we do not add them to the result.\n    // - When only one of `break.vmin` and `break.vmax` is inside the extent and the\n    //  other is outsite, we comply with the extent and display only part of the breaks area,\n    //  because the extent might be determined by user settings (such as `axis.min/max`)\n    ticks.push({\n      value: clampedBrk.vmin,\n      \"break\": {\n        type: 'vmin',\n        parsedBreak: clampedBrk\n      },\n      time: getTimeProps ? getTimeProps(clampedBrk) : undefined\n    });\n    // When gap is 0, start tick overlap with end tick, but we still count both of them. Break\n    // area shape can address that overlapping. `axisLabel` need draw both start and end separately,\n    // otherwise it brings complexity to the logic of label overlapping resolving (e.g., when label\n    // rotated), and introduces inconsistency to users in `axisLabel.formatter` between gap is 0 or not.\n    ticks.push({\n      value: clampedBrk.vmax,\n      \"break\": {\n        type: 'vmax',\n        parsedBreak: clampedBrk\n      },\n      time: getTimeProps ? getTimeProps(clampedBrk) : undefined\n    });\n  });\n  if (breaks.length) {\n    ticks.sort(function (a, b) {\n      return a.value - b.value;\n    });\n  }\n}\n/**\n * If break and extent does not intersect, return null/undefined.\n * If the intersection is only a point at scaleExtent[0] or scaleExtent[1], return null/undefined.\n */\nfunction clampBreakByExtent(brk, scaleExtent) {\n  var vmin = Math.max(brk.vmin, scaleExtent[0]);\n  var vmax = Math.min(brk.vmax, scaleExtent[1]);\n  return vmin < vmax || vmin === vmax && vmin > scaleExtent[0] && vmin < scaleExtent[1] ? {\n    vmin: vmin,\n    vmax: vmax,\n    breakOption: brk.breakOption,\n    gapParsed: brk.gapParsed,\n    gapReal: brk.gapReal\n  } : null;\n}\nfunction parseAxisBreakOption(\n// raw user input breaks, retrieved from axis model.\nbreakOptionList, parse, opt) {\n  var parsedBreaks = [];\n  if (!breakOptionList) {\n    return {\n      breaks: parsedBreaks\n    };\n  }\n  function validatePercent(normalizedPercent, msg) {\n    if (normalizedPercent >= 0 && normalizedPercent < 1 - 1e-5) {\n      // Avoid division error.\n      return true;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      error(msg + \" must be >= 0 and < 1, rather than \" + normalizedPercent + \" .\");\n    }\n    return false;\n  }\n  each(breakOptionList, function (brkOption) {\n    if (!brkOption || brkOption.start == null || brkOption.end == null) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('The input axis breaks start/end should not be empty.');\n      }\n      return;\n    }\n    if (brkOption.isExpanded) {\n      return;\n    }\n    var parsedBrk = {\n      breakOption: clone(brkOption),\n      vmin: parse(brkOption.start),\n      vmax: parse(brkOption.end),\n      gapParsed: {\n        type: 'tpAbs',\n        val: 0\n      },\n      gapReal: null\n    };\n    if (brkOption.gap != null) {\n      var isPrct = false;\n      if (isString(brkOption.gap)) {\n        var trimmedGap = trim(brkOption.gap);\n        if (trimmedGap.match(/%$/)) {\n          var normalizedPercent = parseFloat(trimmedGap) / 100;\n          if (!validatePercent(normalizedPercent, 'Percent gap')) {\n            normalizedPercent = 0;\n          }\n          parsedBrk.gapParsed.type = 'tpPrct';\n          parsedBrk.gapParsed.val = normalizedPercent;\n          isPrct = true;\n        }\n      }\n      if (!isPrct) {\n        var absolute = parse(brkOption.gap);\n        if (!isFinite(absolute) || absolute < 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Axis breaks gap must positive finite rather than (\" + brkOption.gap + \").\");\n          }\n          absolute = 0;\n        }\n        parsedBrk.gapParsed.type = 'tpAbs';\n        parsedBrk.gapParsed.val = absolute;\n      }\n    }\n    if (parsedBrk.vmin === parsedBrk.vmax) {\n      parsedBrk.gapParsed.type = 'tpAbs';\n      parsedBrk.gapParsed.val = 0;\n    }\n    if (opt && opt.noNegative) {\n      each(['vmin', 'vmax'], function (se) {\n        if (parsedBrk[se] < 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Axis break.\" + se + \" must not be negative.\");\n          }\n          parsedBrk[se] = 0;\n        }\n      });\n    }\n    // Ascending numerical order is the prerequisite of the calculation in Scale#normalize.\n    // User are allowed to input desending vmin/vmax for simplifying the usage.\n    if (parsedBrk.vmin > parsedBrk.vmax) {\n      var tmp = parsedBrk.vmax;\n      parsedBrk.vmax = parsedBrk.vmin;\n      parsedBrk.vmin = tmp;\n    }\n    parsedBreaks.push(parsedBrk);\n  });\n  // Ascending numerical order is the prerequisite of the calculation in Scale#normalize.\n  parsedBreaks.sort(function (item1, item2) {\n    return item1.vmin - item2.vmin;\n  });\n  // Make sure that the intervals in breaks are not overlap.\n  var lastEnd = -Infinity;\n  each(parsedBreaks, function (brk, idx) {\n    if (lastEnd > brk.vmin) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('Axis breaks must not overlap.');\n      }\n      parsedBreaks[idx] = null;\n    }\n    lastEnd = brk.vmax;\n  });\n  return {\n    breaks: parsedBreaks.filter(function (brk) {\n      return !!brk;\n    })\n  };\n}\nfunction identifyAxisBreak(brk, identifier) {\n  return serializeAxisBreakIdentifier(identifier) === serializeAxisBreakIdentifier(brk);\n}\nfunction serializeAxisBreakIdentifier(identifier) {\n  // We use user input start/end to identify break. Considered cases like `start: new Date(xxx)`,\n  // Theoretically `Scale#parse` should be used here, but not used currently to reduce dependencies,\n  // since simply converting to string happens to be correct.\n  return identifier.start + '_\\0_' + identifier.end;\n}\n/**\n * - A break pair represents `[vmin, vmax]`,\n * - Only both vmin and vmax item exist, they are counted as a pair.\n */\nfunction retrieveAxisBreakPairs(itemList, getVisualAxisBreak, returnIdx) {\n  var idxPairList = [];\n  each(itemList, function (el, idx) {\n    var vBreak = getVisualAxisBreak(el);\n    if (vBreak && vBreak.type === 'vmin') {\n      idxPairList.push([idx]);\n    }\n  });\n  each(itemList, function (el, idx) {\n    var vBreak = getVisualAxisBreak(el);\n    if (vBreak && vBreak.type === 'vmax') {\n      var idxPair = find(idxPairList,\n      // parsedBreak may be changed, can only use breakOption to match them.\n      function (pr) {\n        return identifyAxisBreak(getVisualAxisBreak(itemList[pr[0]]).parsedBreak.breakOption, vBreak.parsedBreak.breakOption);\n      });\n      idxPair && idxPair.push(idx);\n    }\n  });\n  var result = [];\n  each(idxPairList, function (idxPair) {\n    if (idxPair.length === 2) {\n      result.push(returnIdx ? idxPair : [itemList[idxPair[0]], itemList[idxPair[1]]]);\n    }\n  });\n  return result;\n}\nfunction getTicksLogTransformBreak(tick, logBase, logOriginalBreaks, fixRoundingError) {\n  var vBreak;\n  var brkRoundingCriterion;\n  if (tick[\"break\"]) {\n    var brk = tick[\"break\"].parsedBreak;\n    var originalBreak = find(logOriginalBreaks, function (brk) {\n      return identifyAxisBreak(brk.breakOption, tick[\"break\"].parsedBreak.breakOption);\n    });\n    var vmin = fixRoundingError(Math.pow(logBase, brk.vmin), originalBreak.vmin);\n    var vmax = fixRoundingError(Math.pow(logBase, brk.vmax), originalBreak.vmax);\n    var gapParsed = {\n      type: brk.gapParsed.type,\n      val: brk.gapParsed.type === 'tpAbs' ? fixRound(Math.pow(logBase, brk.vmin + brk.gapParsed.val)) - vmin : brk.gapParsed.val\n    };\n    vBreak = {\n      type: tick[\"break\"].type,\n      parsedBreak: {\n        breakOption: brk.breakOption,\n        vmin: vmin,\n        vmax: vmax,\n        gapParsed: gapParsed,\n        gapReal: brk.gapReal\n      }\n    };\n    brkRoundingCriterion = originalBreak[tick[\"break\"].type];\n  }\n  return {\n    brkRoundingCriterion: brkRoundingCriterion,\n    vBreak: vBreak\n  };\n}\nfunction logarithmicParseBreaksFromOption(breakOptionList, logBase, parse) {\n  var opt = {\n    noNegative: true\n  };\n  var parsedOriginal = parseAxisBreakOption(breakOptionList, parse, opt);\n  var parsedLogged = parseAxisBreakOption(breakOptionList, parse, opt);\n  var loggedBase = Math.log(logBase);\n  parsedLogged.breaks = map(parsedLogged.breaks, function (brk) {\n    var vmin = Math.log(brk.vmin) / loggedBase;\n    var vmax = Math.log(brk.vmax) / loggedBase;\n    var gapParsed = {\n      type: brk.gapParsed.type,\n      val: brk.gapParsed.type === 'tpAbs' ? Math.log(brk.vmin + brk.gapParsed.val) / loggedBase - vmin : brk.gapParsed.val\n    };\n    return {\n      vmin: vmin,\n      vmax: vmax,\n      gapParsed: gapParsed,\n      gapReal: brk.gapReal,\n      breakOption: brk.breakOption\n    };\n  });\n  return {\n    parsedOriginal: parsedOriginal,\n    parsedLogged: parsedLogged\n  };\n}\nvar BREAK_MIN_MAX_TO_PARAM = {\n  vmin: 'start',\n  vmax: 'end'\n};\nfunction makeAxisLabelFormatterParamBreak(extraParam, vBreak) {\n  if (vBreak) {\n    extraParam = extraParam || {};\n    extraParam[\"break\"] = {\n      type: BREAK_MIN_MAX_TO_PARAM[vBreak.type],\n      start: vBreak.parsedBreak.vmin,\n      end: vBreak.parsedBreak.vmax\n    };\n  }\n  return extraParam;\n}\nexport function installScaleBreakHelper() {\n  registerScaleBreakHelperImpl({\n    createScaleBreakContext: createScaleBreakContext,\n    pruneTicksByBreak: pruneTicksByBreak,\n    addBreaksToTicks: addBreaksToTicks,\n    parseAxisBreakOption: parseAxisBreakOption,\n    identifyAxisBreak: identifyAxisBreak,\n    serializeAxisBreakIdentifier: serializeAxisBreakIdentifier,\n    retrieveAxisBreakPairs: retrieveAxisBreakPairs,\n    getTicksLogTransformBreak: getTicksLogTransformBreak,\n    logarithmicParseBreaksFromOption: logarithmicParseBreaksFromOption,\n    makeAxisLabelFormatterParamBreak: makeAxisLabelFormatterParamBreak\n  });\n}"],"names":[],"mappings":"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","ignoreList":[0]}}]
}